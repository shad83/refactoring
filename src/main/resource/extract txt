
目录 ：
译序by侯捷 i
译序by熊节 v
序言（Foreword）by Erich Gamma xiii
前言（Preface）by Martin Fowler xv
什么是重构（Refactoring）？ xvi
本书有些什么？ xvii
谁该阅读本书？ xviii
站在前人的肩膀上 xix
致谢 xix
第1章：重构，第一个案例（Refactoring, a First Example） 1
1.1起点 2
1.2重构的第一步 7
1.3分解并重组Statement() 8
1.4运用多态（polymorphism）取代与价格相关的条件逻辑 34
1.5结语 52
第2章：重构原则（Principles in Refactoring） 53
2.1何谓重构？ 53
2.2为何重构？ 55
2.3何时重构？ 57
2.4怎么对经理说？ 60
2.5重构的难题 62
2.6重构与设计 66
2.7重构与性能（Performance） 69
2.8重构起源何处？ 71
第3章：代码的坏味道（Bad Smells in Code, by Kent Beck and Martin Fowler） 75
3.1 Duplicated Code（重复的代码） 76
3.2 Long Method（过长函数） 76
3.3 Large Class（过大类） 78
3.4 Long Parameter List（过长参数列） 78
3.5 Divergent Change（发散式变化） 79
3.6 Shortgun Surgery（霰弹式修改） 80
3.7 Feature Envy（依恋情结） 80
3.8 Data Clumps（数据泥团） 81
3.9 Primitive Obsession（基本型别偏执） 81
3.10 Switch Statements（switch惊悚现身） 82
3.11 Parallel Inheritance Hierarchies（平行继承体系） 83
3.12 Lazy Class（冗赘类） 83
3.13 Speculative Generality（夸夸其谈未来性） 83
3.14 Temporary Field（令人迷惑的暂时值域） 84
3.15 Message Chains（过度耦合的消息链） 84
3.16 Middle Man（中间转手人） 85
3.17 Inappropriate Intimacy（狎昵关系） 85
3.18 Alternative Classes with Different Interfaces（异曲同工的类） 85 
3.19 Incomplete Library Class（不完善的程序库类） 86 
3.20 Data Class（纯稚的数据类） 86
3.21 Refused Bequest（被拒绝的遗赠） 87
3.22 Comments（过多的注释） 87
第4章：建立测试体系（Building Tests） 89
4.1自我测试码（Self-testing Code）的价值 89
4.2 JUnit测试框架（Testing Framework） 91
4.3添加更多测试 97
第5章：重构名录（Toward a Catalog of Refactoring） 103
5.1重构的记录格式（Format of Refactorings） 103
5.2寻找引用点（Finding References） 105
5.3这些重构准则有多成熟？ 106
第6章：重新组织你的函数（Composing Methods） 109
6.1 Extract Method（提炼函数） 110 
6.2 Inline Method（将函数内联化） 117
6.3 Inline Temp（将临时变量内联化） 119
6.4 Replace Temp With Query（以查询取代临时变量） 120
6.5 Introduce Explaining Variable（引入解释性变量） 124
6.6 Split Temporary Variable（剖解临时变量） 128
6.7 Remove Assignments to Parameters（移除对参数的赋值动作） 131
6.8 Replace Method with Method Object（以函数对象取代函数） 135
6.9 Substitute Algorithm（替换你的算法） 139
第7章：在对象之间移动特性（Moving Features Between Objects） 141
7.1 Move Method（搬移函数） 142
7.2 Move Field（搬移值域） 146
7.3 Extract Class（提炼类） 149
7.4 Inline Class（将类内联化） 154
7.5 Hide Delegate（隐藏「委托关系」） 157 
7.6 Remove Middle Man（移除中间人） 160
7.7 Introduce Foreign Method（引入外加函数） 162 
7.8 Introduce Local Extension（引入本地扩展） 164 
第8章：重新组织你的数据（Organizing Data） 169
8.1 Self Encapsulate Field（自封装值域） 171
8.2 Replace Data Value with Object（以对象取代数据值） 175
8.3 Change Value to Reference（将实值对象改为引用对象） 179
8.4 Change Reference to Value（将引用对象改为实值对象） 183
8.5 Replace Array with Object（以对象取代数组） 186
8.6 Duplicate Observed Data（复制「被监视数据」） 189
8.7 Change Unidirectional Association to Bidirectional 197
（将单向关联改为双向） 
8.8 Change Bidirectional Association to Unidirectional 200
（将双向关联改为单向） 
8.9 Replace Magic Number with Symbolic Constant 204
（以符号常量/字面常量 取代魔法数）
8.10 Encapsulate Field（封装值域） 206
8.11 Encapsulate Collection（封装群集） 208
8.12 Replace Record with Data Class（以数据类取代记录） 217
8.13 Replace Type Code with Class（以类取代型别码） 218
8.14 Replace Type Code with Subclasses 223
（以子类取代型别码） 
8.15 Replace Type Code with State/Strategy 227
（以State/Strategy取代型别码）
8.16 Replace Subclass with Fields（以值域取代子类） 232
第9章：简化条件表达式（Simplifying Conditional Expressions） 237
9.1 Decompose Conditional（分解条件式） 238
9.2 Consolidate Conditional Expression（合并条件式） 240
9.3 Consolidate Duplicate Conditional Fragments 243
（合并重复的条件片段）
9.4 Remove Control Flag（移除控制标记） 245
9.5 Replace Nested Conditional with Guard Clauses 250
（以卫语句取代嵌套条件式） 
9.6 Replace Conditional with Polymorphism（以多态取代条件式） 255
9.7 Introduce Null Object（引入Null对象） 260
9.8 Introduce Assertion（引入断言） 267
第10章：简化函数呼叫（Making Method Calls Simpler） 271
10.1 Rename Method（重新命名函数） 273
10.2 Add Parameter（添加参数） 275
10.3 Remove Parameter（移除参数） 277
10.4 Separate Query from Modifier（将查询函数和修改函数分离） 279
10.5 Parameterize Method（令函数携带参数） 283
10.6 Replace Parameter with Explicit Methods（以明确函数取代参数）285
10.7 Preserve Whole Object（保持对象完整） 288
10.8 Replace Parameter with Method（以函数取代参数） 292
10.9 Introduce Parameter Object（引入参数对象） 295
10.10 Remove Setting Method（移除设值函数） 300
10.11 Hide Method（隐藏你的函数） 303
10.12 Replace Constructor with Factory Method（以工厂方法取代构造函数）304
10.13 Encapsulate Downcast（封装「向下转型」动作） 308
10.14 Replace Error Code with Exception（以异常取代错误码） 310
10.15 Replace Exception with Test（以测试取代异常） 315
第11章：处理概括关系（Dealing with Generalization） 319
11.1 Pull Up Field（值域上移） 320
11.2 Pull Up Method（函数上移） 322
11.3 Pull Up Constructor Body（构造函数本体上移） 325
11.4 Push Down Method（函数下移） 328
11.5 Push Down Field（值域下移） 329
11.6 Extract Subclass（提炼子类） 330
11.7 Extract Superclass（提炼超类） 336
11.8 Extract Interface（提炼接口） 341
11.9 Collapse Hierarchy（折叠继承体系） 344
11.10 Form Template Method（塑造模板函数） 345
11.11 Replace Inheritance with Delegation（以委托取代继承） 352
11.12 Replace Delegation with Inheritance（以继承取代委托） 355
第12章：大型重构（Big Refactorings, by Kent Beck and Martin Fowler） 359
12.1 Tease Apart Inheritance（疏理并分解继承体系） 362
12.2 Convert Procedural Design to Objects 368
（将过程化设计转化为对象设计） 
12.3 Separate Domain from Presentation（将领域和表述/显示分离） 370 
12.4 Extract Hierarchy（提炼继承体系） 375
第13章：重构, 复用, 与现实 379
（Refactoring, Reuse, and Reality, by William Opdyke）
13.1现实的检验 380
13.2为什么开发者不愿意重构他们的程序？ 381
13.3现实的检验（再论） 394
13.4重构的资源和参考数据 394
13.5从重构联想到软件复用和技术传播 395
13.6结语 397
13.7参考文献 397
第14章：重构工具（Refactoring Tools, by Don Roberts and John Brant） 401
14.1使用工具进行重构 401
14.2重构工具的技术标准（Technical Criteria） 403
14.3重构工具的实用标准（Practical Criteria） 405
14.4小结 407
第15章：集成（Put It All Together, by Kent Beck） 409
参考书目（References） 413
原音重现（List of Soundbites） 417
索引

 

重
― 改善既有程式的O ―
Refactoring
Improving the Design of Existing Code
Martin Fowler 著
（以及Kent Beck, John Brant , William Opdyke,
Don Roberts ψ钺崛章的I）
侯捷 / 熊 合g

侯捷g序
Refactoring C Improving the Design of Existing Code
i
侯捷g序g序
by 侯捷
看^F路道班工人幔刻嶂手持式砸道C，C身еgg扁扁的^，在F道
上、枕木gu力地「砍劈」。他在做什N？他在使路基上的碎石K（道
碴）因持m×业恼佣翻D方向、滑游恢茫甚至震碎楦小石K填Mp隙，
以求道碴更o密契合，提供F道更安全更固的w|。
「重」（refactoring）映入眼，我的大X印傅腊喙と+釉业C+枕木
道碴」@右环想面。「重」一~非常清楚地f明了它自身的意x和r值：
在不破目刹旃δ艿那疤嵯拢藉由搬移、提、打散、凝聚…，改善事物的w|。
很多人J同@右信念：「非常的建O需要非常的破摹梗但是F役的用
w、B^半的０浮⑦\D中的系y，容不得推倒重怼＿@r候，在不破目刹
功能的前提下改善w|、化前的可x性、淼U充性和So性做洹
乃至於在^程中找出伏的「臭x」，就成了大受g迎的步前M的良方。
作橐程式T，任l都有看不眼手上程式a的 ― 程式a碜阅汔桌那
菜B，或三月前的自己。面R此境，有人x竦眠^且^；然而根我Α赋
式T」人格特|的了解，更多人盼望插手整D。挽起袖子及履及，其勇可嘉其
]未b。^去或S不得不暴虎{河，忍受LU。F在，有了乐的重t和
密的重手法，「定中求l展」K於有了保障。
是的，把重的概念和想法逐一落在乐的t和烂艿氖址ㄖ中，正是@本
《Refactoring》的最大I。重?! 呵呵，上M的程式T每天的M行式，聿
新r，但要力保C「S持程式原有的可察功能，不нM新臭x」，重就不能
是一靠著天份]⒌乃g，必是一工程。
侯捷g序
Refactoring C Improving the Design of Existing Code
ii
我Ρ的看法
初初x本，腋杏X中所列的S多重目诉^於平淡，重步E^於屑。
@些我平常也都做、T大]⒌幼鳎何必以近乎枯燥的^程小步前M？
然後，uu我才w，正是@拥男〔脚c步前M，不^激，不躁M，再加上完
整的y配套（是的，y之於重O其重要），才是「不砥模不引入臭
x」的最佳保障。我人其不敢置信有l能蚬怨缘匕床阶裱F本所列T
多被我（娜说慕嵌龋┱J槠降而屑的重步E。我人J椋本的最大r
值，除了呼nw品|的追求B度，以及χ「工程性」的JR，最K最重
要的r值在於：建立起吾人於「目前和未碇自踊重工具」的基本理
和作技g上的JRc信。人眼中平淡屑的步E，正是自踊重工具的
基A。C器缺乏人的「大局^」智慧，C器需要的正是切割橐一O小步
E的指令。一板一眼，一次一cc，@正是C器所需要的，也正是C器的ｉL。
本第14章提到，Smalltalk_lh境已含自踊重工具。我K非Smalltalk guy，
我]有用^@些工具。基於技g的w快L樱或我人的孤陋寡），或S如今
你已可以在Java, C++ 等物件向程h境中找到@一自踊重工具。
w技g圈龋重（refactoring）常常被拿砼cO式（design patterns）K。
籍市錾希《Refactoring》也c《Design Patterns》R名。GoF 曾f『O
式橹提供了目恕唬但本作者Martin 亦言『本K]有提供助你完成所有
知名式的重手法，甚至B GoF 的23 知名式都]有能蛉部涵w。』我
可以倪@些中理解技g的方向，以及籍所反映的I限。我K不完全同
Martin 所言『哪怕你手上有一糟糕的O或甚至一F混y，你也可以藉由重
⑺加工成O良好的程式a。』但我十分同意Martin f『你lF所^O不
再是一切幼鞯那疤幔而是在整_l^程中逐u浮F出怼！晃冶容^心，
v不足的程式T在x^本後可能l酵出「先邮衷僬f，死活可重」的心B，
p忽了事前秀O的重要性。任何技g上的f法都必有基本假O；m然重
（或更向上fXP，eXtreme Programming）的精神的_是「不妨先邮帧梗但若草
率行事，代r是很高的。重型_l和p型_l各有所L，各有用，世gKo
f`，任何|西都不能O端。^q不及，皆不可取！
然，「重工程」c「自踊重工具」可槲硐喈大幅度的w品|
提N，@一c我毫oh，K且非常期待!。
侯捷g序
Refactoring C Improving the Design of Existing Code
iii
P於本u作
本在翻gcu作上保留了所有奈兜溃bad smell）、重（refactoring）、O
式（design patterns）的英文名Q，K表F以特殊字型；只在封面软、目、
小祟}中相地o出一根字面或技g意x而做的中文g名。各N「奈兜馈
名Q量就其意xx用面字眼，如泥F、夸夸、^L、^大、^多、情Y、偏
獭Ⅲ@悚、狎俊⒓稚、冗T…。@些其都是助之用，c茶N後的Y（以
及x者批u的根!）。
原各小Ko序。榍⒖肌z索或r的方便，我樽g本加上了序。
本保留相份量的英文gZ，r而英中K（英文橹鳎中文檩o）。@N做
的考量是，本x者不可能不知道class, final, reference, public, package…@些短
的、cJava 程息息相P的用~。另一方面，我_J椋中文缺Ａ艚^挑
x的某些英文gZ，有利於整wx效果。
需要特ef明的用~是Java 程界T用的 "field" 和 "method"。它相於
C++ 的 "data member" 和 "member function"。由於出F次在l繁，榻档椭
英As程度，我把它分eg椤谖弧购汀负式」― 如果 "method" g椤阜
法」，恐怕gZ突出性不高。此外，本「造建立新物件」的 "create" 幼
g椤建」。「static谖慌cinstance谖弧埂「reference物件cvalue物件」
等等t保留部分英文，Kx用如上的特殊字型。凡此NN，相信一M入中您很
快可以感受本gZL格。
本有T多地方裰杏K（中文橹鳎英文檩o）方式，意在告Vx者，我
（g者）深知自己的不足cI限，惟恐造成您χ凶g名~的`解或不T，所
以附上原文。
中文版（本）已⒂⑽陌娼刂2003/06/18 橹怪勘`，修正於本。
侯捷g序
Refactoring C Improving the Design of Existing Code
iv
一cc感想
Martin Fowler 表F於原的作L格是：，塾么名~和略Q。@使得x者
往往需要在字面上揣度推敲。我期盼（K相信）^技g意x的反c、中英gZ
的K、中文表述的努力，中文版（本）在xrg、理解rg和深度上，
^之英文版，能橐匀A文槟刚Z的x者提高10 倍以上的成效。
本由我和熊先生合g。熊第一pass，我後^工作。中文版（本
）樽x者淼拈x和理解上的效益，熊居於首功 ― mf做的是第一
pass，我某醺迤焚|便可看出他多次反覆推敲和文字琢磨的刻痕。至於整wL格、
中英gZ的x定、版面的呈F、乃至於全P技g群的表F，如果有任何差e，
任都是我的!。
作橐Y技g教育者，以及一Y技g鞑フ撸我在超^10 年的著gv程
中，^察了不同e的技g品在x市錾系呐d衰起伏。@些m可反映大h境
下技gI人T及W子的某些面向和取向。我很高d看到我的中文技g籍
（著g皆含）脑缙谟盈MM的初AZ言用，逐uM化到中高AZ言用、作
I系y、技g群恕⒊淌/框架、再至O/分析、w工程。我很高d看到@
拥淖化。我很高d看到《Design Patterns》、《Refactoring》、《Agile…》、《UML…》、
《XP…》之的在中文籍市鲋鞋F身，K期盼它有S富的x者。
中文版（本）支援W站有一「gZ 英中繁」φ毡怼Ｈ绻您有需要，g迎
L，W址如下，Kg迎o我任何意。xx。
侯捷 2003/06/18 于_.新竹
jjhou@jjhou.com（子]箱）
http://www.jjhou.com（繁w）（gZφ毡http://www.jjhou.com/terms.htm）
http://jjhou.csdn.net（w）（gZφ毡http:// jjhou.csdn.net/terms.htm）
熊g序
Refactoring C Improving the Design of Existing Code
v
熊g序g序
by 熊
重的生活方式
得那一天，我把《Refactoring》的全部g稿整理完，l送o侯老r，心
e竟然不意地有了一z惘然。我是一bT的游铮是安於一NT的生活
方式。在那之前的很L一段rge，T了每天晚上翻g@本，T了S手把
}成mail loMartin Fowler 先生，T了xMartin 及r而耐心的回信，
T了在那本}印的、略@粗糙的本上勾勾，T了躺在床上咀嚼回味那
些в幸稽cc英士矜持口吻的~句，T了背後嗡嗡作的老空{…深秋
的L再次染t了香山的~，@N生活方式也就告一段落了。
只有孜幌嗍斓呐笥阎道我在翻g@本，他不太明白槭颤N常把W煸
嘴的我缝秃罾翻g@本 ― 我自己也不明白，大概只能用酆斫
吧。既然已衣食on，既然有一c凫蹲约旱rg，能蛴H手把@本
《Refactoring》翻g出恚也算是o自己的一交代。
第一次到「重」（refactoring）@~，是在2001 年10 月。在r，它的思
想足以令我感到震撼。w自有其美感所在。w工程希望建立完美的需求cO
，按照既有的一的程式a，@是Y的美；快速迭代和RAD 
覆「全知全能」的神，用近乎刀劈斧砍（crack）的方式解Q}，在混沌的循
h往椭F需求，@是解的美；而Kent BeckcMartin Fowler扇苏驹谝黄穑
XP 那敏捷而又乐的方法演[了重的美 ― 我不知道是l最初把refactoring
一~翻g椤钢」，或So心插柳，s成了c睛之P。
我一直是O式（design patterns）的酆谜摺Ｔ在我的思想中，w_l
有一「理想」―然，在@理想S持著完美秩序的，不是哲W家，而
熊g序
Refactoring C Improving the Design of Existing Code
vi
是patterns。O式o我的，不HH是一些}的解Q方案，更有追求完美「理
型」的渴望。但是，Joshua Kerievsky 在那篇著名的《式cXP》（收於《O
限程研究》一）中明白地指出：在O前期使用patterns 常常е逻^度工程
（over-engineering）。@是一酷的F，{ν昝赖淖非o法出用的
程式a，而「用」是w旱挂磺械囊素。囊黄《停止^度工程》_始，Joshua
撰了 "Refactoring to Patterns" 系列文章。@位q太人用他民族性的睿智^X，
敏J地lF了w的後Y主x道路。而O式在w速化的Internet r代重
新WF光x的，又是重的力量。
在一篇流魃V的帖子e，有人把《Refactoring》c《Design Patterns》K列椤Java
行I的}」。在我看磉@NK列其K不蚀_。H上，管我如此喜圻@本
《Refactoring》，但自耐瓿煞g之後，我再也]有x^它。不，不是因槲乙呀
λ熟於心，而是因橹已成了我的另一N生活方式，成了我每天的
「I包cS油」，成了我整F的空馀c水，以至於o再到中ふ胰
何「神I」。而《Design Patterns》，我倒是放在手r常翻，因榭是得不
那N真切。
所以，在你_始x本之前，我有建h要o你：首先，把你的敬畏扔到大
西洋e去，於即⒆得像空馀c水一悠胀ǖ募夹g，你oλ敬畏；其次，
找到合m的_l工具（如果你和我一邮Java 人，那N@「合m的工具」就是
Eclipse），W使用其中的自y和重功能，然後再L使用本介B的任
何技g。卸枋浅淌T的美德之一，^不要因檫@本你得勤快。
最後，即使你完全掌握了@本中的所有|西，也千f不要跟e人吹u。在我
的Fe，程式T常常f：『如果]有卧y和重，我]k法程式。』
好了，感x你耗M一cc的rgA我F在χ、@本《Refactoring》的想
法。Martin Fowler 常f，花一crg碇是值得的，希望你X得花一cr
g看我的文字也是值得的。
熊 2003年6月11日 夜 杭州
P.S. 我想借@y得的C感x一人：我H鄣呐友R。在北京的日子e，是
她陪伴著我度^每日日夜夜，照我的生活，使我能蛴芯力做些喜g的事（包括
翻g@本）。我埋^在幕前敲打IPr，我抱著本冥思苦想r，她o私地
容忍了我的痴迷c冷淡。xx你，，我永h勰恪
目
Refactoring C Improving the Design of Existing Code
vii
目目
Contents
g序by侯捷i
g序by熊v
序言（Foreword）by Erich Gamma xiii
前言（Preface）by Martin Fowler xv
什N是重（Refactoring）？ xvi
本有些什N？ xvii
lx本？ xviii
站在前人的肩膀上xix
致xxix
第1章：重，第一案例（Refactoring, a First Example） 1
1.1起c2
1.2重的第一步7
1.3分解K重MStatement() 8
1.4\用多型（polymorphism）取代cr格相P的l件34
1.5YZ52
第2章：重原t（Principles in Refactoring） 53
2.1何^重？ 53
2.2楹沃？ 55
2.3何r重？ 57
2.4怎N理f？ 60
2.5重的y}62
2.6重cO66
2.7重c效率/性能（Performance） 69
2.8重起源何？ 71
目
Refactoring C Improving the Design of Existing Code
viii
第3章：程式a的奈兜溃Bad Smells in Code, by Kent Beck and Martin Fowler）75
3.1 Duplicated Code（重}的程式a） 76
3.2 Long Method（^L函式） 76
3.3 Large Class（^大e） 78
3.4 Long Parameter List（^L盗校 78
3.5 Divergent Change（l散式化） 79
3.6 Shortgun Surgery（霰式修改） 80
3.7 Feature Envy（依偾榻Y） 80
3.8 Data Clumps（Y料泥F） 81
3.9 Primitive Obsession（基本型e偏蹋 81
3.10 Switch Statements（switch @悚F身） 82
3.11 Parallel Inheritance Hierarchies（平行^承w系） 83
3.12 Lazy Class（冗Te） 83
3.13 Speculative Generality（夸夸其未硇裕 83
3.14 Temporary Field（令人迷惑的r谖唬 84
3.15 Message Chains（^度耦合的息） 84
3.16 Middle Man（中gD手人） 85
3.17 Inappropriate Intimacy（狎筷PS） 85
3.18 Alternative Classes with Different Interfaces（曲同工的e） 85
3.19 Incomplete Library Class（不完善的程式祛e） 86
3.20 Data Class（稚的Y料e） 86
3.21 Refused Bequest（被拒^的z） 87
3.22 Comments（^多的]） 87
第4章：建立yw系（Building Tests） 89
4.1自我ya（Self-testing Code）的r值89
4.2 JUnity框架（Testing Framework） 91
4.3添加更多y97
第5章：重名（Toward a Catalog of Refactoring） 103
5.1重的格式（Format of Refactorings） 103
5.2ふ乙用c（Finding References） 105
5.3@些重t有多成熟？ 106
第6章：重新M你的函式（Composing Methods） 109
6.1 Extract Method（提函式） 110
目
Refactoring C Improving the Design of Existing Code
ix
6.2 Inline Method（⒑式嚷化） 117
6.3 Inline Temp（r嚷化） 119
6.4 Replace Temp With Query（以查取代r担 120
6.5 Introduce Explaining Variable（引入解性担 124
6.6 Split Temporary Variable（剖解r担 128
6.7 Remove Assignments to Parameters（移除档馁x值幼鳎 131
6.8 Replace Method with Method Object（以函式物件取代函式） 135
6.9 Substitute Algorithm（替Q你的演算法） 139
第7章：在物件之g移犹匦裕Moving Features Between Objects） 141
7.1 Move Method（搬移函式） 142
7.2 Move Field（搬移谖唬 146
7.3 Extract Class（提e） 149
7.4 Inline Class（㈩e嚷化） 154
7.5 Hide Delegate（[藏「委PS」） 157
7.6 Remove Middle Man（移除中g人） 160
7.7 Introduce Foreign Method（引入外加函式） 162
7.8 Introduce Local Extension（引入^域性U展） 164
第8章：重新M你的Y料（Organizing Data） 169
8.1 Self Encapsulate Field（自我封b谖唬 171
8.2 Replace Data Value with Object（以物件取代Y料值） 175
8.3 Change Value to Reference（值物件改橐用物件） 179
8.4 Change Reference to Value（⒁用物件改值物件） 183
8.5 Replace Array with Object（以物件取代列） 186
8.6 Duplicate Observed Data（}u「被OY料」） 189
8.7 Change Unidirectional Association to Bidirectional 197
（蜗蜿P改殡p向）
8.8 Change Bidirectional Association to Unidirectional 200
（㈦p向P改蜗颍
8.9 Replace Magic Number with Symbolic Constant 204
（以符常/字面常 取代魔g底郑
8.10 Encapsulate Field（封b谖唬 206
8.11 Encapsulate Collection（封b群集） 208
8.12 Replace Record with Data Class（以Y料e取代） 217
8.13 Replace Type Code with Class（以e取代型e代a） 218
目
Refactoring C Improving the Design of Existing Code
x
8.14 Replace Type Code with Subclasses 223
（以子e取代型e代a）
8.15 Replace Type Code with State/Strategy 227
（以State/Strategy取代型e代a）
8.16 Replace Subclass with Fields（以谖蝗〈子e） 232
第9章：化l件式（Simplifying Conditional Expressions） 237
9.1 Decompose Conditional（分解l件式） 238
9.2 Consolidate Conditional Expression（合l件式） 240
9.3 Consolidate Duplicate Conditional Fragments 243
（合阒匮}的l件片段）
9.4 Remove Control Flag（移除控制旗耍 245
9.5 Replace Nested Conditional with Guard Clauses 250
（以l述句取代巢l件式）
9.6 Replace Conditional with Polymorphism（以多型取代l件式） 255
9.7 Introduce Null Object（引入Null 物件） 260
9.8 Introduce Assertion（引入嘌裕 267
第10章：化函式呼叫（Making Method Calls Simpler） 271
10.1 Rename Method（重新命名函式） 273
10.2 Add Parameter（添加担 275
10.3 Remove Parameter（移除担 277
10.4 Separate Query from Modifier（⒉樵函式和修改函式分x） 279
10.5 Parameterize Method（令函式y担 283
10.6 Replace Parameter with Explicit Methods（以明_函式取代担285
10.7 Preserve Whole Object（保持物件完整） 288
10.8 Replace Parameter with Method（以函式取代担 292
10.9 Introduce Parameter Object（引入滴锛） 295
10.10 Remove Setting Method（移除O值函式） 300
10.11 Hide Method（[藏某函式） 303
10.12 Replace Constructor with Factory Method（以工S函式取代建式）304
10.13 Encapsulate Downcast（封b「向下D型」幼鳎 308
10.14 Replace Error Code with Exception（以常取代e`a） 310
10.15 Replace Exception with Test（以y取代常） 315
第11章：理概括PS（Dealing with Generalization） 319
11.1 Pull Up Field（谖簧弦疲 320
11.2 Pull Up Method（函式上移） 322
目
Refactoring C Improving the Design of Existing Code
xi
11.3 Pull Up Constructor Body（建式本w上移） 325
11.4 Push Down Method（函式下移） 328
11.5 Push Down Field（谖幌乱疲 329
11.6 Extract Subclass（提子e） 330
11.7 Extract Superclass（提超e） 336
11.8 Extract Interface（提介面） 341
11.9 Collapse Hierarchy（摺B^承w系） 344
11.10 Form Template Method（塑造模板函式） 345
11.11 Replace Inheritance with Delegation（以委取代^承） 352
11.12 Replace Delegation with Inheritance（以^承取代委） 355
第12章：大型重（Big Refactorings, by Kent Beck and Martin Fowler） 359
12.1 Tease Apart Inheritance（疏理K分解^承w系） 362
12.2 Convert Procedural Design to Objects 368
（⒊绦蚴皆OD化槲锛O）
12.3 Separate Domain from Presentation（㈩I域和表述/@示分x）370
12.4 Extract Hierarchy（提^承w系） 375
第13章：重, 陀, cF379
（Refactoring, Reuse, and Reality, by William Opdyke）
13.1F的z380
13.2槭颤N_l者不意重他的程式？ 381
13.3F的z（再） 394
13.4重的Y源和⒖假Y料394
13.5闹想到w陀煤图夹g鞑395
13.6YZ397
13.7⒖嘉墨I397
第14章：重工具（Refactoring Tools, by Don Roberts and John Brant） 401
14.1使用工具M行重401
14.2重工具的技g剩Technical Criteria） 403
14.3重工具的用剩Practical Criteria） 405
14.4小Y407
第15章：整合（Put It All Together, by Kent Beck） 409
⒖目（References） 413
原音重F（List of Soundbites） 417
索引419
目
Refactoring C Improving the Design of Existing Code
xii
序言by Erich Gamma
Refactoring C Improving the Design of Existing Code
xiii
序言by Erich Gamma序言
by Erich Gamma
重（refactoring）@概念碜Smalltalk 圈子，]多久就M入了其他Z言I
之中。由於重是framework（框架）_l中不可缺少的一部分，所以framework
_l人T自己的工作r，@gZ就Q生了。他精自己的class hierarchies
（eA芋w系）r，他叫喊自己可以拿掉多少多少行程式ar，重的概
念慢慢浮出水面。framework O者知道，@|西不可能一_始就完全正_，它
S著O者的成L而M化；他也知道，程式a被x和被修改的次颠hh
多於它被的次怠１３殖淌酱a易x、易修改的PI，就是重 D framework
而言如此，σ话丬w也如此。
好O了，有什N}幔亢茱@然：重具有LU。它必修改\作中的程式，
@可能引入一些幽微的e`。如果重方式不恰，可能У裟堤焐踔敌瞧
的成果。如果重r不做好洌不遵守t，LU就更大。你挖掘自己的程式
a，很快lF了一些值得修改的地方，於是你挖得更深。挖得愈深，找到的重
C就越多…於是你的修改也愈多。最後你o自己挖了大坑，s爬不出去了。
榱吮苊庾跃墓，重必系y化M行。我在《Design Patterns》中和另外三
位（f同）作者曾提^：design patterns（O式）refactoring（重）提供
了目恕Ｈ欢「_定目恕怪皇}的一部分而已，改造程式以_目耍是另一
y}。
Martin Fowler 和本另孜蛔髡咔宄揭示了重^程，他槲锛向w_l
所做的I，y以衡量。本解重的原理（principles）和最佳`方式（best
practices），K指出何r何地你_始挖掘你的程式a以求改善。本的核心是
一份完整的重名（catalog of refactoring），其中每一都介B一N^C的
程式aQ手法（code transformation）的C和技g。某些目如Extract Method
序言by Erich Gamma
Refactoring C Improving the Design of Existing Code
xiv
和Move Field 看起砜赡芎\@，但不要掉以p心，因槔斫膺@技g正是有l
不紊地M行重的PI。本所提的@些重t椭你一次一小步地修改你
的程式a，@就p少了^程中的LU。很快你就把@些重t和其名Q加入
自己的_l~典中，K且朗朗上口。
我第一次w有o律的、一次一小步的重，是在30000 英崭呖蘸Kent Beck共
同程式（g]：原文pair-programming，指的是eXtreme Programming
中的所^「成/搭n 程」）。我\用本收的重t，保C每次只走
一步。最後，我@N`方式的效果感到十分@。我不但ψ钺峤Y果更有信
心，而且_l毫σ残×撕芏唷Ｋ以，我高度推]你@些重t，你和你
的程式都⒁虼烁美好。
D Erich Gamma
Object Technology International, Inc.
前言by Martin Fowler
Refactoring C Improving the Design of Existing Code
xv
前言by Martin Fowler前言
by Martin Fowler
那埃有位J⒃L一_l０浮Ｏ到y核心是class hierarchy（eA
w系），看了_l人T所的一些程式a。他lF整w系相凌y，上
classes ψ约旱倪\作方式做了一些假O，@些假O被嵌入K被^承下去。但是@
些假OK不m合所有 subclasses，е赂（overridden）行榉浅７敝亍Ｖ灰在
superclass 茸鳇c修改，就可以p少S多覆必要。在另一些地方，superclass 的某
些意DK未被良好理解，因此其中某些行樵subclasses 戎匮}出F。有一些地
方，好subclasses 做相同的事情，其可以把它搬到class hierarchy 的上
去做。
@位於是建h０附理看看@些程式a，把它整理一下，但是理K不
衷於此，竟程式看上去可以绦校而且０该媾R很大的M度毫Αｌ妒墙理
f，晚些r候再抽rg做@些整理工作。
也把他的想法告V了在@class hierarchy 上工作的程式T，告V他可能l
生的事情。程式T都很敏J，R上就看出}的乐匦浴Ｋ知道@K不全是他
的e，有r候的_需要借助外力才能lF}。程式T立刻用了一商斓rg
整理好@class hierarchy，Kh掉了其中一半程式a，功能毫op。他Υ
十分M意，而且lF系y速度得更快，更容易加入新classes 或使用其他classes。
０附理K不高d。r程排得很o，S多工作要做。系y必在月之後l眩
S多功能等著加M去，@些程式Ts白白耗M商rg，什N活憾]帧Ｔ
先的程式a绦衅磉算正常，他的新O@然有c^於「理」且^於「o
瑕」。０敢出o客舻模是可以有效绦械某淌酱a，不是用以取W究的
完美|西。接下碛纸ㄗh在系y的其他核心部分M行@拥恼理工作，
前言by Martin Fowler
Refactoring C Improving the Design of Existing Code
xvi
@使整０竿ｎD一至二星期。所有@些工作只是榱俗程式a看起砀漂
亮，K不能o系y添加任何新功能。
你@故事有什N看法t你J檫@的建h（更M一步整理程式）是Φ
幔磕因循那句古老的工程VZ幔骸溉绻它可以绦校就不要铀」。
我必承J我自己有某些偏，因槲揖褪悄。六月之後@０感告
失。很大的原因是程式a太}s，o法除e，也o法@得可被接受的性能/效率。
後恚０钢匦樱缀念^_始整系y，Kent Beck 被去做了。
他做了准迥以往的事，其中最重要的一件就是猿忠猿掷m不嗟闹行
整理程式a。@０傅某晒Γ以及重（refactoring）在@成功０钢邪缪莸
角色，鼓舞了我@本的C，如此一砦揖湍虬Kent 和其他一些人已W
的「以重方式改Mw品|」的知R，鞑ソo所有x者。
什N是重（Refactoring）t
所^重是@右^程：「在不改程式a外在行榈那疤嵯拢Τ淌酱a做出
修改，以改M程式的炔拷Y」。重是一N有o律的、^的、有l不紊
的程式整理方法，可以⒄理^程中不小心引入e`的C率降到最低。本|上f，
重就是「在程式a好之後改M它的O」。
「在程式a好之後改M它的O」？@Nf法有c奇怪。按照目前w_l
的理解，我相信先O而後撰a（coding）。首先得有一良好的O，然
後才能_始撰a。但是，S著rg流逝，人不嘈薷某淌酱a，於是根原先O
所得的系y，整wY逐u衰弱。程式a品|慢慢沉S，撰a工作乐的工
程落楹砍y劈的S性行椤
「重」正好c此相反。哪怕你手上有一糟糕的O，甚至是一堆混y的程式
a，你也可以藉由重⑺加工成O良好的程式a。重的每步E都很危
甚至芜^了^，你只需要把某谖唬field）囊class 移到另一class，把
某些程式a囊函式（method）拉出成另一函式，或是在class hierarchy
中把某些程式a推上推下就行了。但是，聚沙成塔，@些小小的修改累e起砭
可以根本改善O品|。@和一般常的「w慢慢腐」的^c恰恰相反。
前言by Martin Fowler
Refactoring C Improving the Design of Existing Code
xvii
透^重（refactoring），你可以找出改的平衡c。你lF所^O不再是一
切幼鞯那疤幔而是在整_l^程中逐u浮F出怼Ｔ谙到yB^程中，你可
以W如何化O；其g淼幕涌梢宰一程式在_l^程中持m保有良
好的O。
本有些什Nt
本是一本重指南（guide to refactoring），I程式T而。我的目的是告
V你如何以一N可控制且高效率的方式M行重。你W@拥闹方式：不
引入臭x（e`），K且有l不紊地改M程式Y。
按照鹘y，籍以一介_^。管我也同意@原t，但是我lF以概
括性的或定x斫榻B重，在不是件容易的事。所以我Q定拿一例做
殚_路先h。第1 章展示一小程式，其中有些常的O缺陷，我把它重
更合格的物件向程式。其g我可以看到重的^程，以及很有用的重
t。如果你想知道重到底是怎N回事，@一章不可不x。
第2 章涵w重的一般性原t、定x，以及M行原因，我也大致介B了重所存
在的一些}。第3章由Kent Beck介B如何嗅出程式a中的「奈兜馈梗以及如
何\用重清除@些奈兜馈！y」在重中扮演非常重要的角色，第4 章介
B如何\用一蔚模ㄔ创a_放的）Java y框架，在程式a中Byh境。
本的核心部分，重名（catalog of refactorings），牡5 章延伸至第12 章。
@不是一份全面性的名，只是一起步，其中包括迄今橹刮以诠ぷ髦姓理下
淼乃有重t。每我想做c什N D 例如Replace Conditional with
Polymorphism D 的r候，@份名就提醒我如何一步一步安全前M。我希望
@是值得你日後一再回的部分。
本介B了其他人的S多研究成果，最後嫡戮褪怯伤之中的孜凰客串就。
Bill Opdyke 在第13章述他⒅技g用於商I_l^程中遇到的一些}。
Don Roberts和John Brant在第14 章展望重技g的未 D 自踊工具。我把最
後一章（第15章）留o重技g的尖大，Kent Beck。
前言by Martin Fowler
Refactoring C Improving the Design of Existing Code
xviii
在Java 中\用重
本全部以Java 撰例。重然也可以在其他Z言中F，而且我也希望@
本能蚪o其他Z言使用者椭。但我X得我最好在本中只使用Java，因
槟鞘俏易钍煜さ恼Z言。我不r下一些提示，告Vx者如何在其他Z言中M
行重，不^我真心希望看到其他人在本基A上ζ渌Z言出更多重方
面的籍。
榱俗畲蟪潭鹊椭x者理解我的想法，我不想使用Java Z言中特e}s的部分。
所以我避免使用inner class（入[e）、reflection（反射C制）、thread（绦
w）以及很多大的Java 特性。@是因槲蚁Ｍ可能清楚展F重的核心。
我提醒你，@些重tK不K行（concurrent）或分散式（distributed）
程。那些主}引出更多重要的事，超越了本的P心。
lx本t
本瞄I程式T，也就是那些以w樯的人。中的示例和，涉
及大量需要x和理解的程式a。@些例子都以Java 完成。之所以xJava，
因樗是一N用愈碛V的Z言，而且任何具C Z言背景的人都可以p
易理解它。Java 是一N物件向Z言，而物件向C制於重有很大椭。
管P注ο笫浅淌酱a，重（refactoring）於系yO也有巨大影。Y深O
（senior designers）和架（architects）也很有必要了解重原理，K
在自己的０钢羞\用重技g。最好是由老Y格、S富的_l人T硪入重
技g，因檫@拥娜俗钅蛄己美斫庵背後的原理，K加以{整，使之m用
於特定工作I域。如果你使用Java 以外的Z言，@一c尤其必要，因槟惚仨把
我o出的例以其他Z言改。
下面我要告V你：如何能蛟诓槐樽x全的情r下得到最多知R。
" 如果你想知道重是什N，x第1 章，其中示例你清楚重^程。
" 如果你想知道槭颤N重，x前烧隆Ｋ告V你「重是什N」以
及「槭颤N重」。
前言by Martin Fowler
Refactoring C Improving the Design of Existing Code
xix
" 如果你想知道在什N地方重，x第3 章。它告V你一些程式a特徵，
@些特徵指出「@e需要重」。
" 如果你想真正（H）M行重，完整x前四章，然後x裥缘亻x重
名（refactoring catalog）。一_始只需概略g[名，看看其中有些什N，
不必理解所有。一旦真正需要施某t，再x它，它椭
你。名是一N具洳樵r值的章，你也SK不想一次把它全部x完。此外
你x一x名之後的「客串章」，特e是第15 章。
站在前人的肩膀上
就在本一_始的此刻，我必f：@本我欠了一大P人情，欠那些在^
去十年中做了大量研究工作K_重I域的人一大P。@本原本由他
之中的某人，但最後s是由我@有rg有精力的人炝吮阋恕
重技g的晌蛔钤碜o者是Ward Cunningham和Kent Beck。他很早就把重
作殚_l^程的一核心成份，K且在自己的_l^程中\用它。尤其需要f明
的是，正因楹Kent 的合作，才我真正看到了重的重要性，K直接激盍宋
@一本。
Ralph Johnson在University of Illinois, Urbana-Champaign（伊利Z大W班{分
校）IЯ艘小M，@小M因其ξ锛技g（object technology）的HI
而名。Ralph很早就是重技g的碜o者，他的一些W生也一直在研究@n}。
Bill Opdyke 的博士文是重研究I域的第一份面成果。John Brant 和Don
Robertst早已不M足於文章了，他了一工具 D 重g[器（Refactoring
Browser），Smalltalk程式施重工程。
致x
管有@些研究成果兔Γ我需要很多f助才能出@本。首先，K且也是
最重要的，Kent Beck o了我巨大的椭。Kent 在底特律（Detroit）和我起他正
在Smalltalk Report撰一篇文 [Beck, hanoi]，拇瞬ハ卤的第一wN子。那
篇文不但我_始注意到重技g，而且我闹小竿怠沽嗽S多想法放到本
第1 章。Kent 也在其他地方椭我，想出「程式a味道」@概念的是他，我
遇到各N困yr，鼓钗业娜艘彩撬，常常和我一起工作助我完成@本的，
前言by Martin Fowler
Refactoring C Improving the Design of Existing Code
xx
是他。我常常忍不住@N想：他完全可以自己把@本得更好。可惜有rg
的人是我，所以我也只能希望自己不要做得太差。
@本的r候，我希望能把一些＜医直接c你分享，所以我非常感激那些
花rg楸添加材料的人。Kent Beck, John Brant, William Opdyke和Don Roberts
撰或合著了本部分章。此外Rich Garzaniti 和Ron Jeffries 臀姨砑恿艘恍┯
用的a充Y料。
在任何像@拥囊槐e，作者都告V你，技g者提供了巨大的椭。一
如以往，Addison-Wesley的Carter和他的秀F是一群精明的者。他是：
# Ken Auer, Rolemodel Software, Inc.
# Joshua Bloch, Sun Microsystems, Java Software
# John Brant, University of Illinois at Urbana-Champaign
# Scott Corley, High Voltage Software, Inc.
# Ward Cunningham, Cunningham & Cunningham, Inc.
# Stéphane Ducasse
# Erich Gamma, Object Technology International, Inc.
# Ron Jeffries
# Ralph Johnson, University of Illinois
# Joshua Kerievsky, Industrial Logic, Inc.
# Doug Lea, SUNY Oswego
# Sander Tichelaar
他大大提高了本的可x性和蚀_性，K且至少去掉了一些任何手稿都可能
有的在e`。在此我要特e感x效果@著的建h，@建h我的看
上去耳目一新：Ward 和Ron 建h我以重前後效果（包括程式a和UML D）K
列的方式第1章，Joshua 建h我在重名中出程式a梗概（code sketches）。
除了正式小M，有很多非正式的者。@些人或看^我的手稿，或P注
我的WK留下ξ液苡椭的意。他是Leif Bennett, Michael Feathers,
Michael Finney, Neil Galarneau, Hisham Ghazouli, Tony Gould, John Isner, Brian
Marick, Ralf Reissing, John Salt, Mark Swanson, Dave Thomas 和Don Wells。我相信
肯定有一些被我z忘的人，容我在此向你道歉，K致上我的x意。
前言by Martin Fowler
Refactoring C Improving the Design of Existing Code
xxi
有一特e有趣的小M，就是「好昭彰」! 的University of Illinois at
Urbana-Champaign x小M。由於本反映出他的多研究成果，我要特e感
x他的成就。@小M成T包括Fredrico "Fred" Balaguer, John Brant, Ian Chai,
Brian Foote, Alejandra Garrido, Zhijiang "John" Han, Peter Hatch, Ralph Johnson,
Songyu "Raymond" Lu, Dragos-Anton Manolescu, Hiroaki Nakamura, James Overturf,
Don Roberts, Chieko Shirai, Les Tyrell和Joe Yoder。
任何好想法都需要在揽岬纳ah境中接受z。我看到重於Chrysler
Comprehensive Compensation（C3）系y起了巨大的影。我要感x那F的所
有成T：Ann Anderson, Ed Anderi, Ralph Beattie, Kent Beck, David Bryant, Bob Coe,
Marie DeArment, Margaret Fronczak, Rich Garzaniti, Dennis Gore, Brian Hacker, Chet
Hendrickson, Ron Jeffries, Doug Joppie, David Kim, Paul Kowalsky, Debbie Mueller,
Tom Murasky, Richard Nutter, Adrian Pantea, Matt Saigeon, Don Thomas 和Don
Wells。和他一起工作所@得的第一手Y料，固了我χ原理和利益的JR。
他在重技g上不噙M步，O大程度地椭我看到：一旦重技g用於vr
多年的大型０钢校可以起怎拥淖饔谩
再一次，我得到了Addison-Wesley的J. Carter Shanklin 和其F的椭，包括Krysia
Bebick, Susan Cestone, Chuck Dutton, Kristin Erickson, John Fuller, Christopher
Guzikowski, Simone Payment 和Genevieve Rajewski。c秀出版商合作是一令
人愉快的，他提供o作者大量的支援和椭。
到支援，橐槐付出最多的，是距x作者最近的人。ξ碚f，那就是我
（F在）的妻子Cindy。感x，我埋首工作的r候，是一畚摇．我投
入中，不嘞肫。
Martin Fowler
Melrose, Massachusetts
fowler@acm.org
http://www.martinfowler.com
http://www.refactoring.com
前言by Martin Fowler
Refactoring C Improving the Design of Existing Code
xxii
1.1 起c
Refactoring C Improving the Design of Existing Code
1
第1 章 重, 第一案例1
重, 第一案例
Refactoring, a First Example
我怎N_始介B重（refactoring）呢？按照鹘y作法，一_始介B某|西r，
首先大致vv它的v史、主要原理等等。可是每有人在錾辖榻B@些|
西，是Tl我的瞌睡x。我的思w_始游，我的眼神_始迷x，直到他或她
拿出例，我才能蛱崞鹁神。例之所以可以拯救我於太之中，因樗我
看事情的真正行M。原理，很容易流於泛泛，又很yf明如何H用。o
出一例，s可以椭我把事情JR清楚。
所以我Q定以一例作楸起c。在此^程中我⒏嬖V你很多重原理，K
且你χ^程有一c感X。然後我才能向你提供一般T的原理介B。
但是，面@介B性例，我遇到了一大}。如果我x褚大型程式，
Τ淌奖旧淼拿枋龊χ^程的描述就太}s了，任何x者都o法掌握（我
了一下，哪怕稍微}s一c的例子都超^100 ）。如果我x褚蛐∫
至於容易理解的程式，又恐怕看不出重的r值。
和任何想要介B「用於真世界中的有用技g」的人一樱我陷入了一十分
典型的呻y困境。我б你看看如何在一我所x竦男〕淌街羞M行重，然
而坦白f，那程式的模根本不值得我那N做。但是如果我o你看的程式a
是大系y的一部分，重技g很快就得重要起怼Ｋ以你一^p@小例
子，一想像它身於一大得多的系y。
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
2
1.1 起c
例非常巍＿@是一影片出租店用的程式，算每一位客的消M金~K列
印蟊恚statement）。操作者告V程式：客租了哪些影片、租期多L，程式便
根租Urg和影片型算出M用。影片分槿：普通片、和片和新片。除
了算M用，要槌？陀算c担稽cS著「租片N是否樾缕」而有不
同。
我以classes 表F@例子中的元素。D1.1 是一UML class diagram（e
D），用以@示@些classes。我逐一列出@些classes 的程式a。
Movie
priceCode:int
Rental
daysRented:int
Customer
statement() *
1 *
1
D1.1 本例一_始的各classes。此D只@示最重要的特性。D中所用符是
UML（Unified Modeling Language，y一建模Z言，[Fowler, UML]）。
Movie（影片）
Movie只是一蔚data class（Y料e）。
public class Movie {
public static final int CHILDRENS = 2;
public static final int REGULAR = 0;
public static final int NEW_RELEASE = 1;
private String _title; // 名Q
private int _priceCode; // r格（代）
public Movie(String title, int priceCode){
_title = title;
_priceCode = priceCode;
}
1.1 起c
Refactoring C Improving the Design of Existing Code
3
public int getPriceCode(){
return _priceCode;
}
public void setPriceCode(int arg){
_priceCode = arg;
}
public String getTitle(){
return _title;
}
}
Rental（租U）
Rental class表示「某客租了一部影片」。
class Rental {
private Movie _movie; // 影片
private int _daysRented; // 租期
public Rental(Movie movie, int daysRented) {
_movie = movie;
_daysRented = daysRented;
}
public int getDaysRented() {
return _daysRented;
}
public Movie getMovie() {
return _movie;
}
}
g]：中文版（本）支援W站提供本章重^程中的各A段完整程式a（共分
七A段），K含y。W址於封底。
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
4
Customer（客）
Customer class 用肀硎绢客。就像其他classes 一樱它也碛匈Y料和相的存
取函式（accessor）：
class Customer {
private String _name; // 姓名
private Vector _rentals = new Vector(); // 租借
public Customer(String name) {
_name = name;
}
public void addRental(Rental arg) {
_rentals.addElement(arg);
}
public String getName() {
return _name;
}
// g]：m下...
Customer 提供了一用以u造蟊淼暮式（method），D1.2 @示@函式
淼慕换ミ^程（interactions）。完整程式a@示於下一。
aCustomer aRental aMovie
*[for all rentals]
getMovie
getPriceCode
getDaysRented
statement
D1.2 statement() 的交互^程（interactions）
1.1 起c
Refactoring C Improving the Design of Existing Code
5
public String statement() {
double totalAmount = 0; // 消M金~
int frequentRenterPoints = 0; // 常客ec
Enumeration rentals = _rentals.elements();
String result = "Rental Record for " + getName() + "\n";
while(rentals.hasMoreElements()){
double thisAmount = 0;
Rental each = (Rental) rentals.nextElement(); // 取得一P租借
//determine amounts for each line
switch(each.getMovie().getPriceCode()) { // 取得影片出租r格
case Movie.REGULAR: // 普通片
thisAmount += 2;
if(each.getDaysRented()>2)
thisAmount += (each.getDaysRented()-2)*1.5;
break;
case Movie.NEW_RELEASE: // 新片
thisAmount += each.getDaysRented()*3;
break;
case Movie.CHILDRENS: // 和片
thisAmount += 1.5;
if(each.getDaysRented()>3)
thisAmount += (each.getDaysRented()-3)*1.5;
break;
}
// add frequent renter points（累加 常客ec）
frequentRenterPoints ++;
// add bonus for a two day new release rental
if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE &&
each.getDaysRented() > 1)
frequentRenterPoints ++;
// show figures for this rental（@示此P租借Y料）
result += "\t" + each.getMovie().getTitle() + "\t" +
String.valueOf(thisAmount) + "\n";
totalAmount += thisAmount;
}
// add footer lines（Y尾列印）
result += "Amount owed is " + String.valueOf(totalAmount) + "\n";
result += "You earned " + String.valueOf(frequentRenterPoints) +
" frequent renter points";
return result;
}
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
6
Υ似鹗汲淌降脑ur
@起始程式o你留下什N印象？我f它O得不好，而且很明@不符合物件
向精神。於@右小程式，@些缺c其]有什NPS。快速而S性（quick
and dirty）地O一蔚某淌K]有e。但如果@是}s系y中具有代表性的
一段，那N我就真的要@程式信心u了。Customer e^那LL的
statement()做的事情在太多了，它做了很多原本由其他class 完成的事情。
即便如此，@程式是能正常工作。所以@只是美W意x上的判啵只是h
陋程式a的海是幔吭谖修改@系y之前的_如此。g器才不在乎
程式a好不好看呢。但是我打算修改系y的r候，就涉及到了人，而人在乎
@些。差诺南到y是很y修改的，因楹茈y找到修改c。如果很y找到修改c，
程式T就很有可能犯e，亩引入「臭x」（bugs）。
在@例子e，我的用粝Ｍο到y做一c修改。首先他希望以HTML 格式
列印蟊恚@泳涂梢灾苯釉诰W上@示，@非常符合潮流。F在你想一想，
@化硎颤N影。看看程式a你就lF，根本不可能在列印HTML 
表的函式中陀茫reuse）目前statement()的任何行椤Ｄ阄┮豢梢宰龅木褪蔷
一全新的htmlStatement()，大量重}statement()的行椤．然，F在做
@不太M力，你可以把statement()}u一份然後按需要修改就是。
但如果M拾l生化，又l生什N事？你必同r修改statement()和
htmlStatement()，K_保商修改的一致性。你後m要再修改r，剪N
（copy-paste）}就浮F出砹恕Ｈ绻你的是一永不需要修改的程式，那
N剪剪NN就好，但如果程式要保存很Lrg，而且可能需要修改，剪N行
就造成在的威{。
F在，第二化砹耍河粝Ｍ改影片分t，但是]有Q定怎N改。
他O想了追N方案，@些方案都影客消M和常客ec的算方式。作
一S富的_l者，你可以肯定：不用籼岢鍪颤N方案，你惟一能颢@得
的保C就是他一定在六月之仍俅涡薷乃。
1.2 重的第一步
Refactoring C Improving the Design of Existing Code
7
榱付分t和Mt的化，程式必statement()作出修改。但如
果我把statement()鹊某淌酱a拷到用以列印HTML 蟊淼暮式中，我就
必_保淼娜魏涡薷脑地方保持一致。S著各Nt得愈碛}s，
m的修改c愈碛y找，不犯e的C也愈碛少。
你的B度也SA向於「量少修改程式」：不管怎Nf，它绦械煤芎谩Ｄ阈
e^牢牢著那句古老的工程W格言：「如果它]模就e铀」。@程式也
S]牡簦但它砹害。它你的生活比^y^，因槟惆lF很y完成客
羲需的修改。@r候就重技g粉墨登隽恕
如果你lF自己需要槌淌教砑右特性，而程式aY使你o法很方便地那N
做，那就先重那程式，使特性的添加比^容易M行，然後再添加特性。
1.2 重的第一步
每我要M行重的r候，第一步E永h相同：我得榧⑿薷牡某淌酱a建立
一M可靠的yh境。@些y是必要的，因管遵循重t可以使我避免
^大多档某粝x引入C，但我竟是人，竟有可能犯e。所以我需要可靠的
y。
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
8
由於statement()的\作Y果是字串（string），所以我首先假O一些客，
他每人各租撞坎煌的影片，然後a生蟊碜执。然後我就可以拿新字串和
手上已z查^的⒖甲执做比^。我把所有y都O置好，俾得以在命令列
入一lJava 命令就把它yy绦衅怼绦羞@些y只需得腌，所以一如你
即⒁到，我常绦兴。
y^程中很重要的一部分，就是y程式於Y果的回蠓绞健Ｋ要不f
"OK"，表示所有新字串都和⒖甲执一樱要不就印出一份失∏危@示}
字串的出F行。@些y都凫蹲晕z（self-checking）。是的，你必y
有能力自我z，否t就得耗M大把rg砘乇Γ@降低你的_l速度。
M行重的r候，我需要倚y，它告V我是否引入了臭x。好的y
是重的根本。花rg建立一良的yC制是完全值得的，因楫你修改程
式r，好yo你必要的安全保障。yC制在重I域的地位在太重要了，
我⒃诘4章它。
重之前，首先z查自己是否有一套可靠的yC制。@些y必有自我z
（self-checking）能力。
1.3 分解K重Mstatement()
第一明@引起我注意的就是L得xV的statement()。每看到@娱LL的函
式，我就想把它大卸八K。要知道，程式a^K愈小，程式a的功能就愈容易管
理，程式a的理和搬移也都愈p。
1.3 分解K重Mstatement()
Refactoring C Improving the Design of Existing Code
9
本章重^程的第一A段中，我⒄f明如何把LL的函式切_，K把^小K的程
式a移至更合m的class 取Ｎ蚁Ｍ降低程式a重}量，亩使新的（列印HTML
蟊碛玫模┖式更容易撰。
第一步E是找出程式a的泥F（logical clump）K\用Extract Method（110）。
本例一明@的泥F就是switch 述句，把它提（extract）到立函式中似
乎比^好。
和任何重t一樱我提一函式r，我必知道可能出什Ne。如果我
提得不好，就可能o程式引入臭x。所以重之前我需要先想出安全作法。由
於先前我已M行^荡芜@重，所以我已把安全步E於後的重名
（refactoring catalog）中了。
首先我得在@段程式ae^找出函式鹊^域担local variables）和
（parameters）。我找到了：each 和thisAmount，前者K未被修改，後者
被修改。任何不被修改的刀伎梢员晃耶成魅胄碌暮式，至於被修
改的稻托韪裢庑⌒摹Ｈ绻只有一被修改，我可以把它作回返值。
thisAmount 是r担其值在每次圈起始被O0，K且在switch 述
句之前不改，所以我可以直接把新函式的回返值x予它。
下面身展示重前後的程式a。重前的程式a在左，重後的程式a在右
。凡是暮式提出淼某淌酱a，以及新程式a所做的任何修改，只要我X得
不是明@到可以一眼看出，就以粗w字耸境硖e提醒你。本章剩N部分⒀
m@N左右比π问健
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
10
public String statement() {
double totalAmount = 0; // 消M金~
int frequentRenterPoints = 0; // 常客ec
Enumeration rentals = _rentals.elements();
String result = "Rental Record for " + getName() + "\n";
while(rentals.hasMoreElements()){
double thisAmount = 0;
Rental each = (Rental) rentals.nextElement(); // 取得一P租借
//determine amounts for each line
switch(each.getMovie().getPriceCode()) { // 取得影片出租r格
case Movie.REGULAR: // 普通片
thisAmount += 2;
if(each.getDaysRented()>2)
thisAmount += (each.getDaysRented()-2)*1.5;
break;
case Movie.NEW_RELEASE: // 新片
thisAmount += each.getDaysRented()*3;
break;
case Movie.CHILDRENS: // 和片
thisAmount += 1.5;
if(each.getDaysRented()>3)
thisAmount += (each.getDaysRented()-3)*1.5;
break;
}
// add frequent renter points（累加 常客ec）
frequentRenterPoints ++;
// add bonus for a two day new release rental
if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &&
each.getDaysRented() > 1)
frequentRenterPoints ++;
// show figures for this rental（@示此P租借Y料）
result += "\t" + each.getMovie().getTitle() + "\t" +
String.valueOf(thisAmount) + "\n";
totalAmount += thisAmount;
}
// add footer lines（Y尾列印）
result += "Amount owed is " + String.valueOf(totalAmount) + "\n";
result += "You earned " + String.valueOf(frequentRenterPoints) +
" frequent renter points";
return result;
}
1.3 分解K重Mstatement()
Refactoring C Improving the Design of Existing Code
11
public String statement() {
double totalAmount = 0;
int frequentRenterPoints = 0;
Enumeration rentals = _rentals.elements();
String result = "Rental Record for " + getName() + "\n";
while (rentals.hasMoreElements()){
double thisAmount = 0;
Rental each = (Rental) rentals.nextElement();
thisAmount = amountFor(each); // 算一P租片M用
// add frequent renter points
frequentRenterPoints ++;
// add bonus for a two day new release rental
if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &&
each.getDaysRented() > 1)
frequentRenterPoints ++;
// show figures for this rental
result += "\t" + each.getMovie().getTitle() + "\t" +
String.valueOf(thisAmount) + "\n";
totalAmount += thisAmount;
}
// add footer lines
result += "Amount owed is " + String.valueOf(totalAmount) + "\n";
result += "You earned " + String.valueOf(frequentRenterPoints) +
" frequent renter points";
return result;
}
private int amountFor(Rental each) { // 算一P租片M用
int thisAmount = 0;
switch(each.getMovie().getPriceCode()) {
case Movie.REGULAR: // 普通片
thisAmount += 2;
if(each.getDaysRented() > 2)
thisAmount += (each.getDaysRented()-2)*1.5;
break;
case Movie.NEW_RELEASE: // 新片
thisAmount += each.getDaysRented() * 3;
break;
case Movie.CHILDRENS: // 和片
thisAmount += 1.5;
if(each.getDaysRented() > 3)
thisAmount += (each.getDaysRented() - 3) * 1.5;
break;
}
return thisAmount;
}
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
12
每次做完@拥男薷闹後，我都要gKy。@一次起^不算太好 D y失
×耍有晒Py告V我l生e`。一迷惑之後我明白了自己犯的e`。
我愚蠢地amountFor() 的回返值型e宣告int，而不是double。
private double amountFor(Rental each) { // 算一P租片M用
double thisAmount = 0;
switch(each.getMovie().getPriceCode()) {
case Movie.REGULAR: // 普通片
thisAmount += 2;
if(each.getDaysRented() > 2)
thisAmount += (each.getDaysRented()-2)*1.5;
break;
case Movie.NEW_RELEASE: // 新片
thisAmount += each.getDaysRented() * 3;
break;
case Movie.CHILDRENS: // 和片
thisAmount += 1.5;
if(each.getDaysRented() > 3)
thisAmount += (each.getDaysRented() - 3) * 1.5;
break;
}
return thisAmount;
}
我常犯@N愚蠢可笑的e`，而@Ne`往往很ylF。在@e，Java o怨o
尤地把double型eDQint型e，而且愉快地做了取整幼 [Java Spec]。
好此@}很容易lF，因槲易龅男薷暮苄。而且我有很好的y。藉
著@意外疏忽，我要U述重步E的本|：由於每次修改的幅度都很小，所以
任何e`都很容易lF。你不必耗M大把rg除e，哪怕你和我一哟中摹
1.3 分解K重Mstatement()
Refactoring C Improving the Design of Existing Code
13
重技gS以微小的步伐修改程式。如果你犯下e`，很容易便可lF它。
由於我用的是Java，所以我需要Τ淌酱a做一些分析，Q定如何理^域怠
如果碛邢的工具，@工作就超瘟恕Smalltalk 的_碛羞@拥墓ぞ撸
Refactoring Browser。\用@工具，重^程非常p，我只需耸境鲂枰重
的程式a，在x沃悬cxExtract Method，入新的函式名Q，一切就自痈愣ā
而且工具^不像我那臃赶掠薮揽尚Φ腻e`。我非常盼望早日出FJava 版本的
重工具u
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
14
F在，我已把原本的函式分K，可以分e理它。我不喜gamountFor()
鹊哪承┳得Q，F在是修改它的r候。
下面是原本的程式a：
private double amountFor(Rental each) { // 算一P租片M用
double thisAmount = 0;
switch(each.getMovie().getPriceCode()) {
case Movie.REGULAR: // 普通片
thisAmount += 2;
if(each.getDaysRented() > 2)
thisAmount += (each.getDaysRented()-2)*1.5;
break;
case Movie.NEW_RELEASE: // 新片
thisAmount += each.getDaysRented() * 3;
break;
case Movie.CHILDRENS: // 和片
thisAmount += 1.5;
if(each.getDaysRented() > 3)
thisAmount += (each.getDaysRented() - 3) * 1.5;
break;
}
return thisAmount;
}
1.3 分解K重Mstatement()
Refactoring C Improving the Design of Existing Code
15
下面是易名後的程式a：
private double amountFor(Rental aRental) { // 算一P租片M用
double result= 0;
switch (aRental.getMovie().getPriceCode()) {
case Movie.REGULAR: // 普通片
result += 2;
if (aRental.getDaysRented() > 2)
result += (aRental.getDaysRented() - 2) * 1.5;
break;
case Movie.NEW_RELEASE: // 新片
result += aRental.getDaysRented() * 3;
break;
case Movie.CHILDRENS: // 和片
result += 1.5;
if (aRental.getDaysRented() > 3)
result += (aRental.getDaysRented() - 3) * 1.5;
break;
}
return result;
}
易名之後我需要重新gKy，_保]有破娜魏|西。
更改得Q是值得的行幔拷^χ档谩：玫某淌酱a清楚表_出自己的功
能，得Q是程式a清晰的PI。如果榱颂岣叱淌酱a的清晰度，需要修改某
些|西的名字，大去做吧。只要有良好的搜/替Q工具，更改名QK不困y。
Z言所提供的型z（strong typing）以及你自己的yC制指出任何你z漏
的|西。住：
任何一傻瓜都能出算C可以理解的程式a。惟有出人容易理解的程式
a，才是秀的程式T。
程式a表F自己的目的，@一c非常重要。x程式a的r候，我常M行
重。@樱S著Τ淌降睦斫庵u加深，我也就不嗟匕堰@些理解嵌入程式a
中，@N一聿挪z忘我曾理解的|西。
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
16
搬移「金~算」程式a
^察amountFor()r，我lF@函式使用了碜Rental class 的Y，s]有
使用碜Customer class的Y。
class Customer...
private double amountFor(Rental aRental) {
double result = 0;
switch (aRental.getMovie().getPriceCode()) {
case Movie.REGULAR:
result += 2;
if (aRental.getDaysRented() > 2)
result += (aRental.getDaysRented() - 2) * 1.5;
break;
case Movie.NEW_RELEASE:
result += aRental.getDaysRented() * 3;
break;
case Movie.CHILDRENS:
result += 1.5;
if (aRental.getDaysRented() > 3)
result += (aRental.getDaysRented() - 3) * 1.5;
break;
}
return result;
}
1.3 分解K重Mstatement()
Refactoring C Improving the Design of Existing Code
17
@立刻使我岩伤是否被放e了位置。^大多登r下，函式放在它所使用
的Y料的所object（或fclass）龋所以amountFor()移到Rental class
去。榱诉@N做，我要\用Move Method（142）。首先把程式a拷到Rental class
龋{整程式a使之m新家，然後重新g。像下面@樱
class Rental...
double getCharge() {
double result = 0;
switch (getMovie().getPriceCode()) {
case Movie.REGULAR:
result += 2;
if (getDaysRented() > 2)
result += (getDaysRented() - 2) * 1.5;
break;
case Movie.NEW_RELEASE:
result += getDaysRented() * 3;
break;
case Movie.CHILDRENS:
result += 1.5;
if (getDaysRented() > 3)
result += (getDaysRented() - 3) * 1.5;
break;
}
return result;
}
在@例子e，「m新家」意味去掉怠４送猓我要在搬移的同r更函
式名Q。
F在我可以y新函式是否正常工作。只要改Customer.amountFor()函式
容，使它委（delegate）新函式即可：
class Customer...
private double amountFor(Rental aRental) {
return aRental.getCharge();
}
F在我可以gKy，看看有]有破牧耸颤N|西。
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
18
下一步E是找出程式中於f函式的所有引用（reference）c，K修改它，
它改用新函式。下面是原本的程式：
class Customer...
public String statement() {
double totalAmount = 0;
int frequentRenterPoints = 0;
Enumeration rentals = _rentals.elements();
String result = "Rental Record for " + getName() + "\n";
while (rentals.hasMoreElements()) {
double thisAmount = 0;
Rental each = (Rental) rentals.nextElement();
thisAmount = amountFor(each);
// add frequent renter points
frequentRenterPoints ++;
// add bonus for a two day new release rental
if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &&
each.getDaysRented() > 1)
frequentRenterPoints ++;
//show figures for this rental
result += "\t" + each.getMovie().getTitle()+ "\t" +
String.valueOf(thisAmount) + "\n";
totalAmount += thisAmount;
}
//add footer lines
result += "Amount owed is " + String.valueOf(totalAmount) + "\n";
result += "You earned " + String.valueOf(frequentRenterPoints) +
" frequent renter points";
return result;
}
1.3 分解K重Mstatement()
Refactoring C Improving the Design of Existing Code
19
本例之中，@步E很危因槲也a生新函式，只有一地方使用了它。
一般情r下你得在可能\用函式的所有classes 中搜ひ槐椤
class Customer
public String statement() {
double totalAmount = 0;
int frequentRenterPoints = 0;
Enumeration rentals = _rentals.elements();
String result = "Rental Record for " + getName() + "\n";
while (rentals.hasMoreElements()) {
double thisAmount = 0;
Rental each = (Rental) rentals.nextElement();
thisAmount = each.getCharge();
// add frequent renter points
frequentRenterPoints ++;
// add bonus for a two day new release rental
if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &&
each.getDaysRented() > 1)
frequentRenterPoints ++;
//show figures for this rental
result += "\t" + each.getMovie().getTitle()+ "\t" +
String.valueOf(thisAmount) + "\n";
totalAmount += thisAmount;
}
//add footer lines
result += "Amount owed is " + String.valueOf(totalAmount) + "\n";
result += "You earned " + String.valueOf(frequentRenterPoints) +
" frequent renter points";
return result;
}
Movie
priceCode:int
Rental
daysRented:int
getCharge()
Customer
statement()
1 *
D1.3 搬移「金~算」函式後，所有classes 的B（state）
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
20
做完@些修改之後（D1.3），下一件事就是去掉f函式。g器告V我是否我
漏掉了什N。然後我M行y，看看有]有破氖颤N|西。
有r候我保留f函式，它呼叫新函式。如果f函式是一public 函式，而我
又不想修改其他class的介面，@便是一N有用的手法。
然我想Rental.getCharge()做些修改，不^r到此橹梗我回到
Customer.statement()：
public String statement() {
double totalAmount = 0;
int frequentRenterPoints = 0;
Enumeration rentals = _rentals.elements();
String result = "Rental Record for " + getName() + "\n";
while (rentals.hasMoreElements()) {
double thisAmount = 0;
Rental each = (Rental) rentals.nextElement();
thisAmount = each.getCharge();
// add frequent renter points
frequentRenterPoints ++;
// add bonus for a two day new release rental
if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &&
each.getDaysRented() > 1)
frequentRenterPoints ++;
//show figures for this rental
result += "\t" + each.getMovie().getTitle()+ "\t" +
String.valueOf(thisAmount) + "\n";
totalAmount += thisAmount;
}
//add footer lines
result += "Amount owed is " + String.valueOf(totalAmount) + "\n";
result += "You earned " + String.valueOf(frequentRenterPoints) +
" frequent renter points";
return result;
}
1.3 分解K重Mstatement()
Refactoring C Improving the Design of Existing Code
21
下一件引我注意的事是：thisAmount如今成多N了。它接受each.getCharge()
的绦薪Y果，然後就不再有任何改。所以我可以\用Replace Temp with Query
（120）把thisAmount除去。
public String statement() {
double totalAmount = 0;
int frequentRenterPoints = 0;
Enumeration rentals = _rentals.elements();
String result = "Rental Record for " + getName() + "\n";
while (rentals.hasMoreElements()) {
Rental each = (Rental) rentals.nextElement();
// add frequent renter points
frequentRenterPoints ++;
// add bonus for a two day new release rental
if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &&
each.getDaysRented() > 1) frequentRenterPoints ++;
//show figures for this rental
result += "\t" + each.getMovie().getTitle()+ "\t" +
String.valueOf(each.getCharge()) + "\n";
totalAmount += each.getCharge();
}
//add footer lines
result += "Amount owed is " + String.valueOf(totalAmount) + "\n";
result += "You earned " + String.valueOf(frequentRenterPoints)
+ " frequent renter points";
return result;
}
}
做完@份修改，我立刻gKy，保C自己]有破娜魏|西。
我喜g量除去@一r怠r低往形成}，它е麓罅
被魅ィ而其完全]有@N必要。你很容易失去它的E，尤其在LL
的函式之中更是如此。然我@N做也需付出效率上的代r，例如本例的M用就
被算了纱巍５是@很容易在Rental class 中被最佳化。而且如果程式a有合
理的M和管理，最佳化有很好的效果。我⒃p.69 的「重c效率/性能」一
@}。
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
22
提「常客ec算」程式a
下一步要Α赋？头ec算」做似理。c档挠算影片N而有不同，不
^不像收Mt有那N多化。看硭坪跤欣碛砂逊ec算任放在Rental class
身上。首先我需要Α赋？头ec算」@部分程式a（以下粗w部分）\用
Extract Method（110）重t：
public String statement() {
double totalAmount = 0;
int frequentRenterPoints = 0;
Enumeration rentals = _rentals.elements();
String result = "Rental Record for " + getName() + "\n";
while (rentals.hasMoreElements()) {
Rental each = (Rental) rentals.nextElement();
// add frequent renter points
frequentRenterPoints ++;
// add bonus for a two day new release rental
if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE)
&& each.getDaysRented() > 1) frequentRenterPoints ++;
//show figures for this rental
result += "\t" + each.getMovie().getTitle()+ "\t" +
String.valueOf(each.getCharge()) + "\n";
totalAmount += each.getCharge();
}
//add footer lines
result += "Amount owed is " + String.valueOf(totalAmount) + "\n";
result += "You earned " + String.valueOf(frequentRenterPoints)
+ " frequent renter points";
return result;
}
}
1.3 分解K重Mstatement()
Refactoring C Improving the Design of Existing Code
23
再一次我又要ふ^域怠＿@e再一次用到了each，而它可以被做魅
新函式中。另一r凳frequentRenterPoints。本例中的它在被使用之
前已先有初值，但提出淼暮式K]有x取值，所以我不需要⑺作
鬟M去，只需λ绦小父教碣x值幼鳌梗appending assignment, operator+=）
就行了。
我完成了函式的提，重新gKy；然後做一次搬移，再g、再y。重
r最好小步前M，如此一矸稿e的C率最小。
class Customer...
public String statement() {
double totalAmount = 0;
int frequentRenterPoints = 0;
Enumeration rentals = _rentals.elements();
String result = "Rental Record for " + getName() + "\n";
while (rentals.hasMoreElements()) {
Rental each = (Rental) rentals.nextElement();
frequentRenterPoints += each.getFrequentRenterPoints();
//show figures for this rental
result += "\t" + each.getMovie().getTitle()+ "\t" +
String.valueOf(each.getCharge()) + "\n";
totalAmount += each.getCharge();
}
//add footer lines
result += "Amount owed is " + String.valueOf(totalAmount) + "\n";
result += "You earned " + String.valueOf(frequentRenterPoints) +
" frequent renter points";
return result;
}
class Rental...
int getFrequentRenterPoints() {
if ((getMovie().getPriceCode() == Movie.NEW_RELEASE)
&& getDaysRented() > 1)
return 2;
else
return 1;
}
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
24
我利用重前後的UML（Unified Modeling Language，y一建模Z言）D形（D1.4
至D1.7）Y才所做的修改。和先前一樱左是修改前的D，右是修改後
的D。
Movie
priceCode:int
Rental
daysRented:int
getCharge()
Customer
statement()
1 *
D1.4 「常客ec算」函式被提及搬移之前的class diagrams
aCustomer aRental aMovie
*[for all rentals]
getCharge
getPriceCode
getDaysRented
statement
D1.5 「常客ec算」函式被提及搬移之前的sequence diagrams
1.3 分解K重Mstatement()
Refactoring C Improving the Design of Existing Code
25
Movie
priceCode:int
Rental
daysRented:int
getCharge()
getFrequentRenterPoints()
Customer
statement()
1 *
D1.6 「常客ec算」函式被提及搬移之後的class diagrams
aCustomer aRental aMovie
*[for all rentals]
getCharge
getPriceCode
getFrequentRenterPoints
statement
getPriceCode
D1.7 「常客ec算」函式被提及搬移之後的sequence diagrams
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
26
去除r
正如我在前面提^的，r悼赡苁}。它只在自己所俚暮式中有效，
所以它助L「冗L而}s」的函式。@e我有r担烧叨际怯
Customer物件相P的Rental物件中@得某量。不ASCII版或HTML
版都需要@些量。我打算\用Replace Temp with Query（120），K利用所^的
query method砣〈totalAmount和frequentRentalPoints@r怠
由於class 鹊娜魏魏式都可以取用（呼叫）上述所^query methods，所以它能
虼龠M^乾Q的O，而非冗L}s的函式：
class Customer...
public String statement() {
double totalAmount = 0;
int frequentRenterPoints = 0;
Enumeration rentals = _rentals.elements();
String result = "Rental Record for " + getName() + "\n";
while (rentals.hasMoreElements()) {
Rental each = (Rental) rentals.nextElement();
frequentRenterPoints += each.getFrequentRenterPoints();
//show figures for this rental
result += "\t" + each.getMovie().getTitle()+ "\t" +
String.valueOf(each.getCharge()) + "\n";
totalAmount += each.getCharge();
}
//add footer lines
result += "Amount owed is " + String.valueOf(totalAmount) + "\n";
result += "You earned " + String.valueOf(frequentRenterPoints) +
" frequent renter points";
return result;
}
1.3 分解K重Mstatement()
Refactoring C Improving the Design of Existing Code
27
首先我以Customer class的getTotalCharge()取代totalAmount：
class Customer...
public String statement() {
int frequentRenterPoints = 0;
Enumeration rentals = _rentals.elements();
String result = "Rental Record for " + getName() + "\n";
while (rentals.hasMoreElements()) {
Rental each = (Rental) rentals.nextElement();
frequentRenterPoints += each.getFrequentRenterPoints();
//show figures for this rental
result += "\t" + each.getMovie().getTitle()+ "\t" +
String.valueOf(each.getCharge()) + "\n";
}
//add footer lines
result += "Amount owed is " +
String.valueOf(getTotalCharge()) + "\n";
result += "You earned " +
String.valueOf(frequentRenterPoints) +
" frequent renter points";
return result;
}
// g]：此即所^query method
private double getTotalCharge() {
double result = 0;
Enumeration rentals = _rentals.elements();
while (rentals.hasMoreElements()) {
Rental each = (Rental) rentals.nextElement();
result += each.getCharge();
}
return result;
}
@K不是Replace Temp with Query（120）的最吻r。由於totalAmount 在
圈炔勘毁x值，我不得不把圈}u到query method中。
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
28
重之後，重新gKy，然後以同邮址ㄌ理frequentRenterPoints：
class Customer...
public String statement() {
int frequentRenterPoints = 0;
Enumeration rentals = _rentals.elements();
String result = "Rental Record for " + getName() + "\n";
while (rentals.hasMoreElements()) {
Rental each = (Rental) rentals.nextElement();
frequentRenterPoints += each.getFrequentRenterPoints();
//show figures for this rental
result += "\t" + each.getMovie().getTitle()+ "\t" +
String.valueOf(each.getCharge()) + "\n";
}
//add footer lines
result += "Amount owed is " +
String.valueOf(getTotalCharge()) + "\n";
result += "You earned " + String.valueOf(frequentRenterPoints) +
" frequent renter points";
return result;
}
1.3 分解K重Mstatement()
Refactoring C Improving the Design of Existing Code
29
public String statement() {
Enumeration rentals = _rentals.elements();
String result = "Rental Record for " + getName() + "\n";
while (rentals.hasMoreElements()) {
Rental each = (Rental) rentals.nextElement();
//show figures for this rental
result += "\t" + each.getMovie().getTitle()+ "\t" +
String.valueOf(each.getCharge()) + "\n";
}
//add footer lines
result += "Amount owed is " +
String.valueOf(getTotalCharge()) + "\n";
result += "You earned " +
String.valueOf(getTotalFrequentRenterPoints()) +
" frequent renter points";
return result;
}
// g]：此即所^query method
private int
int result = 0;
Enumeration rentals = _rentals.elements();
while (rentals.hasMoreElements()) {
Rental each = (Rental) rentals.nextElement();
result += each.getFrequentRenterPoints();
}
return result;
}
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
30
D1.8至D1.11分e以UML class diagram（eD）和interaction diagram（交互
作用D）展示statement()重前後的化。
Movie
priceCode:int
Rental
daysRented:int
getCharge()
getFrequentRenterPoints()
Customer
statement()
1 *
D1.8 「量算」函式被提前的class diagram
aCustomer aRental aMovie
*[for all rentals]
getCharge
getPriceCode
getFrequentRenterPoints
statement
getPriceCode
D1.9 「量算」函式被提前的sequence diagram
1.3 分解K重Mstatement()
Refactoring C Improving the Design of Existing Code
31
Movie
priceCode:int
Rental
daysRented:int
getCharge()
getFrequentRenterPoints()
Customer
statement()
getTotalCharge()
getTotalFrequentRenterPoints
1 *
D1.10 「量算」函式被提後的class diagram
aCustomer aRental aMovie
*[for all rentals] getCharge
getPriceCode
getTotalFrequentRenterPoints
statement
getPriceCode
*[for all rentals] getFrequentRenterPoints
getTotalCharge
D1.11 「量算」函式被提後的sequence diagram
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
32
做完@次重，有必要停下硭伎家幌隆４蠖抵都p少程式a量，但@
次s增加了程式a量，那是因Java 1.1 需要大量述句（statements）碓O置一
和（summing）圈。哪怕只是一蔚目和圈，每元素只需一行程式
a，L的支援程式a也需要六行之多。@其是任何程式T都熟悉的T法，
但程式a盗窟是太多了。
@次重存在另一}，那就是效率。原本程式a只绦while 圈一次，新
版本要绦腥次。如果while 圈耗r很多，就可能大大降低程式的效率。
榱诉@原因，S多程式T就不M行@重幼鳌５是注意我的用~：如
果和可能。除非我M行uy（profile），否t我o法_定圈的绦rg，也o法
知道@圈是否被常使用以至於影系y的整w效率。重r你不必心@
些，最佳化r你才需要心它，但那r候你已於一比^有利的位置，有更
多x窨梢酝瓿捎行ё罴鸦（p.69 的）。
F在，Customer class 鹊娜魏纬淌酱a都可以取用@些query methods 了。如果
系y他需要@些Y，也可以p地query methods 加入Customer class 介
面。如果]有@些query methods，其他函式就必了解Rental class，K自行建
立圈。在一}s系y中，@⑹钩淌降木y度和Soy度大大增加。
你可以很明@看出恚htmlStatement()和statement()是不同的。F在，我
下「重」的帽子，戴上「添加功能」的帽子。我可以像下面@泳
htmlStatement()，K添加相y：
public String htmlStatement() {
Enumeration rentals = _rentals.elements();
String result = "<H1>Rentals for <EM>" + getName() +
"</EM></H1><P>\n";
while (rentals.hasMoreElements()) {
Rental each = (Rental) rentals.nextElement();
//show figures for each rental
result += each.getMovie().getTitle()+ ": " +
String.valueOf(each.getCharge()) + "<BR>\n";
}
//add footer lines
result += "<P>You owe <EM>" +
String.valueOf(getTotalCharge()) +
"</EM><P>\n";
result += "On this rental you earned <EM>" +
String.valueOf(getTotalFrequentRenterPoints()) +
"</EM> frequent renter points<P>";
return result;
}
1.3 分解K重Mstatement()
Refactoring C Improving the Design of Existing Code
33
透^算的提，我可以完成一htmlStatement()，K陀茫reuse）原本
statement()鹊乃有算。我不必剪剪NN，所以如果算tl生改，我
只需在程式中做一修改。完成其他任何型的蟊硪捕己芸於且很容易。@次
重K不花很多rg，其中大半rg我用砼清楚程式a所做的事，而@是我o
如何都得做的。
前述有些重aSASCII 版本e^拷^ ― 主要是圈O置部分。更深入
的重幼骺梢郧宄@些重}程式a。我可以把理表^（header）、表尾（footer）
和蟊砑目的程式a都分e提出怼ＴForm Template Method（345）例中，
你可以看到如何做@些幼鳌５是，F在用粲珠_始嘀咕了，他湫薷挠捌
分t。我尚未清楚他想怎N做，但似乎新分法很快就要引入，F有的
分法R上就要更。c之相的M用算方式和常客ec算方式都待Q定，
F在就Τ淌阶鲂薷模肯定是愚蠢的。我必M入M用算和常客ec算中，
把「因l件而的程式a」（g]：指的是switch述句鹊case子句）替Q掉，
@硬拍淼母淖上一颖Ｗo膜。F在，重新戴回「重」@帽子。
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
34
1.4 \用多型（polymorphism）取代cr格相P的l件
@}的第一部分是switch 述句。在另一物件的傩裕attribute）基A上\
用switch 述句，K不是什N好主意。如果不得不使用，也在物件自己的Y料
上使用，而不是在e人的Y料上使用。
class Rental...
double getCharge() {
double result = 0;
switch (getMovie().getPriceCode()) {
case Movie.REGULAR:
result += 2;
if (getDaysRented() > 2)
result += (getDaysRented() - 2) * 1.5;
break;
case Movie.NEW_RELEASE:
result += getDaysRented() * 3;
break;
case Movie.CHILDRENS:
result += 1.5;
if (getDaysRented() > 3)
result += (getDaysRented() - 3) * 1.5;
break;
}
return result;
}
1.4 \用多型（polymorphism）取代cr格相P的l件
Refactoring C Improving the Design of Existing Code
35
@暗示getCharge()移到Movie class e^去：
class Movie...
double getCharge(int daysRented) {
double result = 0;
switch (getPriceCode()) {
case Movie.REGULAR:
result += 2;
if (daysRented > 2)
result += (daysRented - 2) * 1.5;
break;
case Movie.NEW_RELEASE:
result += daysRented * 3;
break;
case Movie.CHILDRENS:
result += 1.5;
if (daysRented > 3)
result += (daysRented - 3) * 1.5;
break;
}
return result;
}
榱俗它得以\作，我必把「租期L度」作鬟fM去。然，「租期L
度」碜Rental物件。算M用r需要煞葙Y料：「租期L度」和「影片型」。
槭颤N我x瘛⒆馄陂L度鹘oMovie物件」而不是「⒂捌型鹘oRental 物
件」呢？因楸鞠到y可能l生的化是加入新影片型，@N化в胁环定A
向。如果影片型有所化，我希望掀起最小的i漪，所以我x裨Movie 物件
扔算M用。
我把上述M方法放MMovie class e^，然後修改Rental 的getCharge()，
它使用@新函式（D1.12 和D1.13）：
class Rental...
double getCharge() {
return _movie.getCharge(_daysRented);
}
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
36
搬移getCharge()之後，我以相同手法理常客ec算。@游揖桶迅影片
型而化的所有|西，都放到了影片型所俚class 中。以下是重前的程式
a：
class Rental...
int getFrequentRenterPoints() {
if ((getMovie().getPriceCode() == Movie.NEW_RELEASE) &&
getDaysRented() > 1)
return 2;
else
return 1;
}
Movie
priceCode:int
Rental
daysRented:int
getCharge()
getFrequentRenterPoints()
Customer
statement()
htmlStatement()
getTotalCharge()
getTotalFrequentRenterPoints()
*
1
D1.12 本所的函式被移到Movie class 戎前，系y的class diagram。
1.4 \用多型（polymorphism）取代cr格相P的l件
Refactoring C Improving the Design of Existing Code
37
重如下：
class Rental...
int getFrequentRenterPoints() {
return _movie.getFrequentRenterPoints(_daysRented);
}
class Movie...
int getFrequentRenterPoints(int daysRented) {
if ((getPriceCode() == Movie.NEW_RELEASE) && daysRented > 1)
return 2;
else
return 1;
}
Movie
priceCode:int
Rental
daysRented:int
getCharge()
getFrequentRenterPoints()
Customer
statement()
htmlStatement()
getTotalCharge()
getTotalFrequentRenterPoints()
*
1
getCharge(days:int)
getFrequentRenterPoints(days:int)
D1.13 本所的函式被移到Movie class 戎後，系y的class diagram。
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
38
K於…我淼嚼^承（inheritance）
我有捣N影片型，它以不同的方式回答相同的}。@起砗芟subclasses
的工作。我可以建立Movie的三subclasses，每都有自己的M法（D1.14）。
Movie
getCharge
Childrens Movie
getCharge
Regular Movie
getCharge
New Release Movie
getCharge
D1.14 以^承C制表F不同的影片型
@N一砦揖涂梢赃\用多型（polymorphism）砣〈switch 述句了。很z憾的是
@e有小}，不能@N帧Ｒ徊坑捌可以在生命L期刃薷淖约旱姆诸，一
物件s不能在生命L期刃薷淖约核俚class。不^是有一解Q方法：State
pattern（式）[Gang of Four]。\用它之後，我的classes 看起硐D1.15。
Price
getCharge
Childrens Price
getCharge
Regular Price
getCharge
New Release Price
getCharge
Movie
getCharge
return price.getCharge
1
D1.15 \用State pattern（式）表F不同的影片
1.4 \用多型（polymorphism）取代cr格相P的l件
Refactoring C Improving the Design of Existing Code
39
加入@一娱g接性，我就可以在Price 物件冗M行subclassing 幼鳎ㄗg]：一
如D1.15），於是便可在任何必要r刻修改r格。
如果你很熟悉Gang of Four 所列的各N式（patterns），你可能：『@是一
State 是一Strategy？』答案取Q於Price class 究竟代表M方式（此r
我喜g把它叫做Pricer或PricingStrategy），或是代表影片的某B（state。
例如「Star Trek X是一部新片」）。在@A段，於式（和其名Q）的x穹
映出你Y的想法。此刻我把它橛捌的某NB（state）。如果未砦矣X
得Strategy能更好地f明我的意D，我再重它，修改名字，以形成Strategy。
榱艘入State 式，我使用三重t。首先\用Replace Type Code with
State/Strategy（227），「c型e相依的行椤梗type code behavior）搬移至State
式取Ｈ会徇\用Move Method（142）switch述句移到Price class e^。最
後\用Replace Conditional with Polymorphism（255）去掉switch述句。
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
40
首先我要使用Replace Type Code with State/Strategy（227）。第一步E是Α概c
型e相依的行椤故褂Self Encapsulate Field（171），_保任何r候都透^getting
和setting 函式磉\用@些行椤Ｓ伸抖党淌酱a碜云渌classes，所以多
函式都已使用getting函式。但建式（constructor）仍然直接存取r格代（g
]：程式中的 _priceCode）：
class Movie...
public Movie(String name, int priceCode) {
_title = name;
_priceCode = priceCode;
}
1.4 \用多型（polymorphism）取代cr格相P的l件
Refactoring C Improving the Design of Existing Code
41
我可以用一setting函式泶替：
class Movie
public Movie(String name, int priceCode) {
_title = name;
setPriceCode(priceCode); // g]：@就是一set method
}
然後gKy，_保]有破娜魏|西。F在我加入新class，K在Price 物件
中提供「c型e相依的行椤埂榱F@一c，我在Price 燃尤胍抽象函
式（abstract method），K在其所有subclasses 中加上的具w函式（concrete
method）：
abstract class Price {
abstract int getPriceCode(); // 取得r格代
}
class ChildrensPrice extends Price {
int getPriceCode() {
return Movie.CHILDRENS;
}
}
class NewReleasePrice extends Price {
int getPriceCode() {
return Movie.NEW_RELEASE;
}
}
class RegularPrice extends Price {
int getPriceCode() {
return Movie.REGULAR;
}
}
F在我可以g@些新classes 了。
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
42
F在，我需要修改Movie class 鹊摹r格代」存取函式（get/set函式，如下），
它使用新class。下面是重前的幼樱
public int getPriceCode() {
return _priceCode;
}
public setPriceCode (int arg) {
_priceCode = arg;
}
private int _priceCode;
1.4 \用多型（polymorphism）取代cr格相P的l件
Refactoring C Improving the Design of Existing Code
43
@意味我必在Movie class 缺４嬉Price 物件，而不再是保存一
_priceCode怠４送馕疫需要修改存取函式（g]：即get/set函式）：
class Movie...
public int getPriceCode() { // 取得r格代
return _price.getPriceCode();
}
public void setPriceCode(int arg) { // O定r格代
switch (arg) {
case REGULAR: // 普通片
_price = new RegularPrice();
break;
case CHILDRENS: // 和片
_price = new ChildrensPrice();
break;
case NEW_RELEASE: // 新片
_price = new NewReleasePrice();
break;
default:
throw new IllegalArgumentException("Incorrect Price Code");
}
}
private Price _price;
F在我可以重新gKy，那些比^}s的函式根本不知道世界已了
骸
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
44
F在我要getCharge()施Move Method（142）。下面是重前的程式a：
class Movie...
double getCharge(int daysRented) {
double result = 0;
switch (getPriceCode()) {
case Movie.REGULAR:
result += 2;
if (daysRented > 2)
result += (daysRented - 2) * 1.5;
break;
case Movie.NEW_RELEASE:
result += daysRented * 3;
break;
case Movie.CHILDRENS:
result += 1.5;
if (daysRented > 3)
result += (daysRented - 3) * 1.5;
break;
}
return result;
}
1.4 \用多型（polymorphism）取代cr格相P的l件
Refactoring C Improving the Design of Existing Code
45
搬移幼骱芎巍Ｏ旅媸侵後的程式a：
class Movie...
double getCharge(int daysRented) {
return _price.getCharge(daysRented);
}
class Price...
double getCharge(int daysRented) {
double result = 0;
switch (getPriceCode()) {
case Movie.REGULAR:
result += 2;
if (daysRented > 2)
result += (daysRented - 2) * 1.5;
break;
case Movie.NEW_RELEASE:
result += daysRented * 3;
break;
case Movie.CHILDRENS:
result += 1.5;
if (daysRented > 3)
result += (daysRented - 3) * 1.5;
break;
}
return result;
}
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
46
搬移之後，我就可以_始\用Replace Conditional with Polymorphism（255）了。
下面是重前的程式a：
class Price...
double getCharge(int daysRented) {
double result = 0;
switch (getPriceCode()) {
case Movie.REGULAR:
result += 2;
if (daysRented > 2)
result += (daysRented - 2) * 1.5;
break;
case Movie.NEW_RELEASE:
result += daysRented * 3;
break;
case Movie.CHILDRENS:
result += 1.5;
if (daysRented > 3)
result += (daysRented - 3) * 1.5;
break;
}
return result;
}
1.4 \用多型（polymorphism）取代cr格相P的l件
Refactoring C Improving the Design of Existing Code
47
我的作法是一次取出一case分支，在相的class冉立一覆函式（overriding
method）。先RegularPrice_始：
class RegularPrice...
double getCharge(int daysRented) {
double result = 2;
if (daysRented > 2)
result += (daysRented - 2) * 1.5;
return result;
}
@函式覆（overrides）了父e中的case 述句，而我r把後者留在原
不印，F在gKy，然後取出下一case 分支，再gKy。（榱吮ＷC
被绦械牡拇_是subclass 程式a，我喜g故意G一e`M去，然後它绦校
y失　｀蓿我是不是有c太偏塘耍浚
class ChildrensPrice...
double getCharge(int daysRented) {
double result = 1.5;
if (daysRented > 3)
result += (daysRented - 3) * 1.5;
return result;
}
class NewReleasePrice...
double getCharge(int daysRented) {
return daysRented * 3;
}
理完所有case分支之後，我就把Price.getCharge()宣告abstract：
class Price...
abstract double getCharge(int daysRented);
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
48
F在我可以\用同邮址ㄌ理getFrequentRenterPoints()。重前的幼尤缦
（g]：其中有「c型e相依的行椤梗也就是「判嗍欠樾缕」那幼鳎：
class Movie...
int getFrequentRenterPoints(int daysRented) {
if ((getPriceCode() == Movie.NEW_RELEASE) && daysRented > 1)
return 2;
else
return 1;
}
1.4 \用多型（polymorphism）取代cr格相P的l件
Refactoring C Improving the Design of Existing Code
49
首先我把@函式移到Price class e^：
Class Movie...
int getFrequentRenterPoints(int daysRented) {
return _price.getFrequentRenterPoints(daysRented);
}
Class Price...
int getFrequentRenterPoints(int daysRented) {
if ((getPriceCode() == Movie.NEW_RELEASE) && daysRented > 1)
return 2;
else
return 1;
}
但是@一次我不把superclass 函式宣告abstract。我只是椤感缕型」a生一
覆函式（overriding method），K在superclass 攘粝乱已定x的函式，使
它成橐环NAO行椤
// g]：在新片中a生一覆函式（overriding method）
Class NewReleasePrice
int getFrequentRenterPoints(int daysRented) {
return (daysRented > 1) ? 2: 1;
}
// g]：在superclass缺Ａ羲，使它成橐环NAO行
Class Price...
int getFrequentRenterPoints(int daysRented){
return 1;
}
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
50
引入State 式花了我不少力猓值得幔窟@N做的收是：如果我要修改任何
cr格有P的行椋或是添加新的定r剩或是加入其他取Q於r格的行椋
程式的修改容易得多。@程式的其N部分K不知道我\用了State 式。
於我目前碛械倪@N小量行碚f，任何功能或特性上的修改也S都Q不上
什N困y，但如果在一更}s的系y中，有十多cr格相P的函式，程式的
修改y易度就有很大的^e。以上所有修改都是小步EM行，M度似乎太^
慢，但是]有任何一次我需要打_除e器（debugger），所以整^程H上很快
就^去了。我本章所用的rg，h比修改那些程式a的rg多太多了。
F在我已完成了第二重要的重行椤拇耍修改「影片分Y」，或是
改「M用算t」、改常客ec算t，都容易多了。D1.16 和D1.17
描述State式於r格Y所起的作用。
1.4 \用多型（polymorphism）取代cr格相P的l件
Refactoring C Improving the Design of Existing Code
51
aCustomer aRental aMovie
*[for all rentals] getCharge
getCharge(days)
getTotalFrequentRenterPoints
statement
*[for all rentals] getFrequentRenterPoints
getTotalCharge
aPrice
getCharge(days)
getFrequentRenterPoints(days)
getFrequentRenterPoints(days)
D1.16 \用State pattern（式）r的Interaction diagram
Price
getCharge(days:int)
getFrequentRenterPoints(days:int)
ChildrensPrice
getCharge(days:int)
RegularPrice
getCharge(days:int)
NewReleasePrice
getCharge (days:int)
getFrequentRenterPoints(days:int)
Movie
title: String
getCharge (days:int)
getFrequentRenterPoints(days:int)
1
Rental
dayRented: int
getCharge ()
getFrequentRenterPoints()
Customer
name: String
statement()
htmlStatement()
getTotalCharge()
getTotalFrequentRenterPoints()
*
1
D1.17 加入State pattern（式）之後的class diagram
第1 章 重, 第一案例
Refactoring C Improving the Design of Existing Code
52
1.5 YZ
@是一蔚睦子，但我希望它能你於「重是什N幼印褂幸稽c感X。
例中我已示了重t，包括Extract Method（110)、Move Method（142）、
Replace Conditional with Polymorphism（255）、Self Encapsulate Field（171） 、
Replace Type Code with State/Strategy（227）。所有@些重行槎际关任的分
配更合理，程式a的So更p。重後的程式L格，⑹分不同於程序式
（procedural）L格，後者也S是某些人T的L格。不^一旦你T了@N重
後的L格，就很y再回到（再M足於）Y化L格了。
@例子o你上的最重要一n是「重的奏」：y、小修改、y、小修改、
y、小修改…。正是@N奏重得以快速而安全地前M。
如果你看懂了前面的例子，你已理解重是怎N回事了。F在，我了
解一些背景、原理和理（不太多！）。
g]：中文版（本）支援W站提供本章重^程中的各A段完整程式a（共分
七A段），K含y。W址於封底。
第1 章 重, 第一案例
2.1 何^重
Refactoring C Improving the Design of Existing Code
53
第2 章 重原t2
重原t
Principles in Refactoring
前面所e的例子已你χ（refactoring）有了一良好的感受。F在，
我回^看看重的PI原t，以及重r需要考]的某些}。
2.1 何^重
我是不太芬槭颤N|西下定x，因槊人θ魏|西都有自己的定x。但
是你一本r，你得x褡约M意的定x。在重@}目上，我的定x
以Ralph JohnsonF和其他相P研究成果榛A。
首先要f明的是：上下文不同，「重」@~有煞N不同的定x。你可能
X得@挺┤说模ㄎ揖褪沁@N想），不^理自然Z言本砭褪羌┤说氖拢@
只不^是又一例而已。
第一定x是名~形式：
重（名~）：w炔拷Y的一N{整，目的是在不改「w之可察行椤
前提下，提高其可理解性，降低其修改成本。
你可以在後m章中找到S多重例，T如Extract Method（110）和Pull Up Field
（320）等等。一般而言重都是w的小改樱但重可以包含另一重。
例如Extract Class（149）通常包含Move Method（142）和Move Field（146）。
第2 章 重原t
Refactoring C Improving the Design of Existing Code
54
「重」的另一用法是釉~形式：
重（釉~）：使用一系列重t（手法），在不改「w之可察行椤骨疤
下，{整其Y。
所以，在w_l^程中，你可能花上敌r的rgM行重，其g可能用上
凳不同的重t。
曾有人@我：『重就只是整理程式a幔俊哪撤N角度碚f，是的！但
我J橹不止於此，因樗提供了一N更高效且受控的程式a整理技g。自
\用重技g後，我lF自己Τ淌酱a的整理比以前更有效率。@是因槲抑道
使用哪些重t，我也知道以怎拥姆绞绞褂盟才能㈠e`p到最少，
而且在每一可能出e的地方我都加以y。
我的定x需要往煞矫U展。首先，重的目的是使w更容易被理解和修改。
你可以在w炔孔龊芏嘈薷模但必w「可受^察之外部行椤怪辉斐珊
小化，或甚至不造成化。c之形成Ρ鹊氖恰感率最佳化」。和重一樱
效率最佳化通常不改M件的行椋ǔ了绦兴俣龋，只改其炔拷Y。
但是烧叱霭lc不同：效率最佳化往往使程式a^y理解，但榱说玫剿需的效
率你不得不那N做。
我要{的第二c是：重不改w「可受^察之行椤埂 重之後w功
能一如以往。任何用簦不K端用艋虺淌T，都不知道已有|西l生了化。
（g]：「可受^察之行椤蛊也包括效率，因樾率是可以被^察的。不^
我想我o需太挑剔@些用~。）
身帽子
上述第二c引出了Kent Beck的「身帽子」比喻。使用重技g_lwr，你
把自己的rg分配o煞N截然不同的行椋骸柑砑有鹿δ堋购汀钢」。添加新
功能r，你不修改既有程式a，只管添加新功能。透^y（Ky正常
绦校，你可以衡量自己的工作M度。重r你就不能再添加功能，只管改M程
式Y。此r你不添加任何y（除非lF先前z漏的任何|西），只在^
Ρ匾（用以理介面化）r才修改y。
2.2 楹沃？
Refactoring C Improving the Design of Existing Code
55
w_l^程中，你可能lF自己常Q帽子。首先你L添加新功能，
然後你意R到：如果把程式Y改一下，功能的添加容易得多。於是你Q一
帽子，做一褐工作。程式Y{整好後，你又Q上原先的帽子，^m添
加新功能。新功能正常工作後，你又lF自己的a造成程式y以理解，於是你
又Q上重帽子…。整^程或S只花十分，但o何r你都清楚自己戴
的是哪一帽子。
2.2 楹沃？
我不想把重f成治百病的f`丹，它^Σ皇撬^的「y子」1。不^它的_
很有r值，m不是一wy子s是一把「yQ子」，可以椭你始K良好地控制
自己的程式a。重是工具，它可以（K且）榱艘韵目的而被\用：
「重」改MwO
如果]有重，程式的O逐u腐∽|。人只槎唐谀康模或是在完全
理解整wO之前，就Q然修改程式a，程式⒅u失去自己的Y，程式T愈
碛y透^x源a而理解原本O。重很像是在整理程式a，你所做的就是
所有|西回到的位置上。程式aY的流失是累e性的。愈y看出程式a
所代表的O意涵，就愈y保o其中O，於是O就腐〉糜快。常性的
重可以椭程式aS持自己有的形B。
同油瓿梢患事，O不良的程式往往需要更多程式a，@常常是因槌淌酱a在
不同的地方使用完全相同的述句做同拥氖隆Ｒ虼烁倪MO的一重要方向就是
消除重}程式a（Duplicate Code）。@幼鞯闹匾性著眼於未怼３淌酱a
量p少K不使系y绦懈快，因檫@Τ淌降绦熊E缀]有任何明@影。
然而程式a盗p少⑹刮砜赡艿某淌叫薷幼魅菀椎枚唷３淌酱a愈多，正_
的修改就愈困y，因橛懈多程式a需要理解。你在@鹤隽它c修改，系ys不
如A期那庸ぷ鳎因槟阄丛修改另一 ― 那旱某淌酱a做著缀跬耆一拥
事情，只是所h境略有不同。如果消除重}程式a，你就可以_定程式a⑺
有事物和行槎贾槐硎鲆淮危惟一一次，@正是秀O的根本。
1 g]：「y子」（silver bullet）是美家喻缘谋扔鳌Ｃ民g流髟A之夜狼
人出]，只有以y子射穿狼人心K，才能制服狼人。
第2 章 重原t
Refactoring C Improving the Design of Existing Code
56
「重」使w更易被理解
脑S多角度碚f，所^程式O，便是c算C交。你程式a告V算C
做什N事，它的回t是精_按照你的指示行印Ｄ愕眉r填a「想要它做什N」
和「告V它做什N」之g的p隙。@N程模式的核心就是「蚀_f出吾人所欲」。
除了算C外，你的源a有其他x者：月之後可能有另一位程式TL
x懂你的程式aK做一些修改。我很容易忘@第二位x者，但他才是最重要
的。算C是否多花了^M行g，又有什NPS呢？如果一程式T花
M一周rg硇薷哪扯纬淌酱a，那才PS重大 ― 如果他理解你的程式a，@
修改原本只需一小r。
}在於，你努力程式\D的r候，你不想到未沓霈F的那_l者。是
的，是改一下我的_l奏，Τ淌酱a做m修改，程式a得更易
理解。重可以椭我程式a更易x。一_始M行重r，你的程式a可以
正常绦校但Y不蚶硐搿Ｔ谥上花一ccrg，就可以程式a更好地表
_自己的用途。@N程模式的核心就是「蚀_f出你的意思」。
P於@一c，我]必要表F得如此o私。很多r候那「未淼拈_l者」就是我
自己。此r重就@得尤其重要了。我是很卸璧某淌T，我的卸璞憩F形式
之一就是：是不住自己^的程式a。事上於任何立可查的|西我都
故意不去它，因槲遗掳炎约旱哪X袋塞爆。我是量把住的|西M程
式e^，@游揖筒槐赜住它了。@N一砦揖筒槐靥心Old Peculier （g]：
一N有名的芽酒）[Jackson] ⒐馕业哪X胞。
@N可理解性有另一方面的作用。我利用重f助我理解不熟悉的程式a。
我看到不熟悉的程式a，我必著理解其用途。我先看尚谐淌酱a，然後
自己f：『噢，是的，它做了@些那些…』。有了重@大武器在手，我不
M足於@N一cX中w。我真正邮中薷某淌酱a，它更好地反映出我的
理解，然後重新绦校看它是否仍然正常\作，以此z我的理解是否正_。
一_始我所做的重都像@油Ａ粼诩枝末上。S著程式au，我lF
自己可以看到一些以前看不到的O用娴|西。如果不Τ淌酱a做@些修改，
也S我永h看不它，因槲业穆明才智不足以在X子e把@一切都想像出怼
Ralph Johnson把@N「早期重」描述椤覆恋舸羯系奈酃福使你看得更h」。
研究程式ar我lF，重把我У礁高的理解哟紊稀Ｈ绻]有重，我_不
到@N哟巍
2.3 何r重？
Refactoring C Improving the Design of Existing Code
57
「重」助你找到臭x（bugs）
Τ淌酱a的理解，可以椭我找到臭x。我承J我不太擅L除e。有些人只要盯
著一大段程式a就可以找出e面的臭x，我可不行。但我lF如果我Τ淌酱aM
行重，我就可以深入理解程式a的作椋K恰到好地把新的理解反回去。
搞清楚程式Y的同r，我也清楚了自己所做的一些假O，倪@角度碚f，不
找到臭x都y矣。
@我想起了Kent Beck常形容自己的一句：『我不是ゴ蟮某淌T；我只
是有著一些秀T的好程式T而已。』重能椭我更有效地出固
健（robust）的程式a。
「重」助你提高程速度
K於，前面的一切都wY到了@最後一c：重椭你更快速地_l程式。
起碛悬c`反直X。我到重，人很容易看出它能蛱岣咂焚|。改善O
、提N可x性、p少e`，@些都是提高品|。但@y道不降低_l速度幔
我烈相信：良好O是快速w_l的根本。事上碛辛己迷O才可能_成
快速的_l。如果]有良好O，或S某一段rg饶愕倪M展迅速，但毫拥脑O
很快就你的速度慢下怼Ｄ把rg花在除e上面，o法添加新功能。修改
rg愈碛L，因槟惚仨花愈碛多的rg去理解系y、ふ抑匮}程式a。S
著你o最初程式打上一又一的a（patch），新特性需要更多程式a才能
F。真是盒匝h。
良好O是S持w_l速度的根本。重可以椭你更快速地_lw，因
它阻止系y腐∽|，它甚至可以提高O品|。
2.3 何r重？
我重，常常有人我怎影才胖rg表。我是不是每
月就ｉT安排星期磉M行重呢？
第2 章 重原t
Refactoring C Improving the Design of Existing Code
58
缀跞魏吻r下我都反ｉT艹rgM行重。在我看恚重本砭筒皇且
件「特e艹rg做」的事情，重SrS地M行。你不橹而重，
你之所以重，是因槟阆胱e的什N事，而重可以椭你把那些事做好。
三次法t（The Rule of Three）
Don Roberts o了我一lt：第一次做某件事r只管去做；第二次做似的事
a生反感，但o如何是做了；第三次再做似的事，你就重。
事不^三，三t重。（Three strikes and you refactor.）
添加功能r一阒
最常的重rC就是我想ow添加新特性的r候。此r，重的第一原因
往往是榱椭我理解需要修改的程式a。@些程式a可能是e人的，也可能
是我自己的。o何r只要我想理解程式a所做的事，我就自己：是否能
@段程式aM行重，使我能更快理解它。然後我就重。之所以@N做，
部分原因是榱俗我下次再看@段程式ar容易理解，但最主要的原因是：如果
在前M^程中把程式aY理清，我就可以闹欣斫飧多|西。
在@e，重的另一原恿κ牵撼淌酱a的Oo法椭我p添加我所需要的
特性。我看著O，然後ψ约赫f：「如果用某N方式碓O，添加特性
得多」。@N情r下我不因樽约哼^去的e`而懊 ― 我用重a它。
之所以@N做，部分原因是榱俗未碓黾有绿匦r能蚋p一些，但最主要
的原因是：我lF@是最快捷的途健Ｖ是一快速流车倪^程，一旦完成
重，新特性的添加就更快速、更流场
修ae`r一阒
除e^程中\用重，多半是榱俗程式a更具可x性。我看著程式aK努力
理解它的r候，我用重椭改善自己的理解。我lF以@N程序硖理程式a，
常常能椭我找出臭x。你可以@N想：如果收到一份e`蟾妫@就是需要
重的信，因轱@然程式a不蚯逦 ― 不蚯逦到你一目了然lF臭x。
2.3 何r重？
Refactoring C Improving the Design of Existing Code
59
程式ar一阒
很多公司都做常B性的程式a工作（code reviews），因檫@N活涌梢愿
善_lr。@N活佑兄於在_lF中鞑ブR，也有助於^有的_
l者把知R鬟fo比^欠缺的人，K椭更多人理解大型w系y中的更多
部分。程式a工作於清晰程式a也很重要。我的程式a也Sξ易约
碚f很清晰，λ人t不然。@是o法避免的，因橐_l者O身地槟切
不熟悉自己所做所榈娜嗽O想，在太困y了。程式a也更多人有C提
出有用的建h，竟我在一星期之饶蛳氤龅暮命c子很有限。如果能得到e
人的椭，我的生活舒服得多，所以我是期待更多。
我lF，重可以椭我e人的程式a。_始重前我可以先x程式a，
得到一定程度的理解，K提出一些建h。一旦想到一些c子，我就考]是否可
以通^重立即p地F它。如果可以，我就邮帧＿@幼隽状我葬幔
我可以把程式a看得更清楚，提出更多恰的建h。我不必想像程式a「是
什N印梗我可以「看」它是什N印ｌ妒俏铱梢垣@得更高哟蔚恼JR。如果
不M行重，我永ho法得到@拥恼JR。
重可以椭程式a工作得到更具w的Y果。不H@得建h，而且其中S
多建h能蛄⒖F。最K你`中得到比以往多得多的成就感。
榱俗^程正常\D，你的F必保持精。就我的，最好是一
者搭配一原作者，共同理@些程式a。者提出修改建h，然後扇斯
同判噙@些修改是否能蛲高^重pF。果真能蛉绱耍就一起著手修改。
如果是比^大的O工作，那N，在一^大F缺Ａ舳喾N^c通常更
好一些。此r直接展示程式a往往不是最佳k法。我喜g\用UML 示意D展FO
，K以CRC 卡展示w情。Q句f，我和某FM行O，而和
e（我唬者M行程式a。
O限程（Extreme Programming）[Beck, XP] 中的「搭n（成Γ┚程」（Pair
Programming）形式，把程式a的eO性l]到了O致。一旦裼眠@N形式，
所有正式_l任斩加擅_l者在同一台C器上M行。@颖阍陂_l^程中形
成SrM行的程式a工作，而重也就被包含在_l^程攘恕
第2 章 重原t
Refactoring C Improving the Design of Existing Code
60
槭颤N重有用（Why Refactoring Works）
― Kent Beck
程式有擅r值：「今天可以槟阕鍪颤N」和「明天可以槟阕鍪颤N」。大多r候，
我都只P注自己今天想要程式做什N。不是修湾e`或是添加特性，我都是
了程式能力更，它在今天更有r值。
但是系y今天（下）的行椋只是整故事的一部分，如果]有J清@一c，你o
法L期氖戮程工作。如果你「榍笸瓿山裉烊铡苟袢〉氖址ㄊ鼓悴豢赡茉诿魈
完成明天的任眨那N你是失　５是，你知道自己今天需要什N，s不一定知道
自己明天需要什N。也S你可以猜到明天的需求，也S吧，但肯定有些事情出乎你
的意料。
於今天的工作，我了解得很充分；於明天的工作，我了解得不虺浞帧５如果我
粹只是榻裉旃ぷ鳎明天我⑼耆o法工作。
重是一l[束`的道路。如果你lF昨天的Q定已不m合今天的情r，放心改
@Q定就是，然後你就可以完成今天的工作了。明天，喔，明天回^看今天的理
解也SX得很幼稚，那r你可以改你的理解。
是什N程式如此y以相c？下P此刻，我想起四原因，它是：
! y以x的程式，y以修改。
! 重}（duplicated logic）的程式，y以修改。
! 添加新行r需修改既有程式a者，y以修改。
! а}sl件（complex conditional logic）的程式，y以修改。
因此，我希望程式 (1) 容易x，(2) 所有都只在惟一地c指定，(3) 新的改
不危及F有行椋(4) 可能伪磉_l件（conditional logic）。
重是@右^程：它在一目前可绦械某淌缴线M行，企D在「不改程式行椤
的情r下x予上述美好性|，使我能蚶^m保持高速_l，亩增加程式的r值。
2.4 怎N理f？
「怎N跟理f重的事？」@是我最常被到的}之一。如果@位理懂
技g，那N向他介B重不很困y。如果@位理只ζ焚|感d趣，那N
}就集中到了「品|」上面。此r，在^程中使用重，就是一不e的
k法。大量研究Y果@示，「技g」是p少e`、提高_l速度的一l重要
2.4 怎N理f？
Refactoring C Improving the Design of Existing Code
61
途健ｋS便找一本P於、查或w_l程序的看看，闹姓倚┳钚乱C，
可以大多到理JR的r值。然後你就可以把重作「意
引入程式a取沟姆椒硎褂茫@很容易。
然，很多理嘴巴上f自己「品|印梗其更多是「M度印埂＿@N情
r下我o他一^有h的建h：不要告V理！
@是在搞破幔课也贿@酉搿＼w_l者都是I人士。我的工作就是可
能快速造出高效w。我的告V我，於快速造w，重可砭薮
椭。如果需要添加新功能，而原本Os又使我o法方便地修改，我lF先「M
行重」再「添加新功能」更快些。如果要修ae`，我需得先理解w工作
方式，而我lF重是理解w的最快方式。受M度拥慕理要我可能快速
完事，至於怎N完成，那就是我的事了。我J樽羁斓姆绞骄褪侵，所以我就
重。
g接雍椭（Indirection and Refactoring）
― Kent Beck
『算C科W是@右婚T科W：它相信所有}都可以藉由多一g接樱indirection）
斫Q。』― Dennis DeBruler
由於w工程g接尤绱俗硇模你不@大多抵都槌淌揭入了更多
g接印Ｖ往往把大型物件拆成小型物件，把大型函式拆成小型函式。
但是，g接邮且槐p刃ΑＣ看伟岩|西分成煞荩你就需要多管理一|西。
如果某物件委（delegate）另一物件，後者又委另一物件，程式愈加y以x。
基於@^c，你希望量p少g接印
e急，夥！g接佑兴的r值。下面就是g接拥哪承r值：
! 允S共享（To enable sharing of logic）。比如f一子函式（submethod）在
不同的地c被呼叫，或superclass 中的某函式被所有subclasses 共享。
! 分_解「意D」和「作」（To explain intention and implementation separately）。
你可以x衩class 和函式的名字，@o了你一解自己意D的C。class 或
函式炔t解F@意D的作法。如果class 和函式炔坑忠浴父小卧的意
D」砭，你所的程式a就可以「c其Y中的大部分重要Y贤ā埂
! ⒆化加以隔x（To isolate change）。很可能我在不同地c使用同一物件，其
中一地c我想改物件行椋但如果修改了它，我就要冒「同r影商」的L
U。榇宋易龀鲆subclass，K在需要修改引用@subclass。F在，我可以修
第2 章 重原t
Refactoring C Improving the Design of Existing Code
62
改@subclass 而不必承「o意中影另一」的LU。
! l件加以a（To encode conditional logic）。物件有一N匪夷所思的C制：
多型息（polymorphic messages），可以`活性而清晰地表_l件。只要@
式l件被D化橛息（message2）形式，往往便能降低程式a的重}、增加清
晰度、K提高性。
@就是重[颍涸诒３窒到yF有行榈那疤嵯拢如何才能提高系y的品|或降低其
成本，亩使它更有r值？
@[蛑凶畛Ｒ的稻褪牵耗闳绾慰创你自己的程式。找出一缺乏「g接永
益」之，在不修改F有行榈那疤嵯拢樗加入一g接印，F在你@得了一更
有r值的程式，因樗有^高的品|，我在明天（未恚┦芤妗
⑦@N方法c「小心翼翼的事前O」做比^。推y性O是D在任何一行
程式aQ生之前就先系y碛兴有秀品|，然後程式T⒊淌酱a塞M@健的
骨架中就行了。@^程的}在於：太容易猜e。如果\用重，你就永h不面
R全Pe`的危U。程式自始至K都能保持一致的行椋而你又有C槌淌教砑痈
多r值不菲的品|。
有一N比^少的重[颍赫页霾恢档玫拈g接樱K⑺拿掉。@Ng接映Ｒ
中介函式（intermediate methods）形式出F，也S曾有^I，但芳A已逝。它也可
能是M件，你本砥谕在不同地c共享它，或它表F出多型性（polymorphism），
最Ks只在一使用之。如果你找到@N「寄生式g接印梗把它扔掉。如此一
你@得一更有r值的程式，不是因樗取得了更多（先前所列）的四N秀品|，
而是因樗以更少的g接荧@得一佣嗟秀品|。
2.5 重的y}
W一N可以大幅提高生a力的新技gr，你是y以察X其不m用的龊稀Ｍ
常你在一特定鼍爸W它，@鼍巴往是０浮＿@N情r下你很y看出
什N造成@N新技g成效不彰或甚至形成危害。十年前，物件技g（object tech.）
的情r也是如此。那r如果有人我「何r不要使用物件」，我很y回答。K非
我J槲锛十全十美、]有I限性 ― 我最反@N盲目B度，而是管我知道
它的好，但_不知道其I限性在哪骸
2 g]：此的「息」（message）是指物件向古典述中的意x。在那N龊现校
「呼叫某函式（method）」就是「送出息（message）o某物件（object）」。
2.5 重的y}
Refactoring C Improving the Design of Existing Code
63
F在，重的境也是如此。我知道重的好，我知道重可以o我的
工作泶故挚傻玫母淖。但是我]有@得足虻慕，我看不到它的
I限性。
@一小比我希望的要短。呵胰绱税伞ｋS著更多人W重技巧，我也
它有更多了解。δ愣言@意味：m然我QJ槟L一下重，@得它
所提供的利益，但在此同r，你也rrO控其^程，注意ふ抑可能引入
的}。我知道你所遭遇的}。S著χ的了解日益增多，我⒄
出更多解Qk法，K清楚知道哪些}是真正y以解Q的。
Y料欤Databases）
「重」常出}的一I域就是Y料臁＝^大多瞪逃贸淌蕉寂c它背後的
database schema（Y料毂砀窠Y）o密耦合（coupled）在一起，@也是database
schema 如此y以修改的原因之一。另一原因是Y料w移（migration）。就算你
非常小心地⑾到y分樱layered），database schema 和物件模型（object model）
g的依降至最低，但database schema 的改是你不得不w移所有Y料，@
可能是件漫L而┈的工作。
在「非物件Y料臁梗nonobject databases）中，解Q@}的k法之一就是：
在物件模型（object model）和Y料炷Ｐ停database model）之g插入一分隔
（separate layer），@就可以隔x模型各自的化。升某一模型ro需同r
升另一模型，只需升上述的分隔蛹纯伞＿@拥姆指增加系y}s度，
但可以o你很大的`活度。如果你同r碛卸Y料欤或如果Y料炷Ｐ洼^
}s使你y以控制，那N即使不M行重，@分隔右彩呛苤匾的。
你o需一_始就插入分隔樱可以在lF物件模型得不定r再a生它。@
你就可以槟愕母淖找到最好的U效。
_l者而言，物件Y料旒扔椭也有妨K。某些物件向Y料焯峁┎煌版
本的物件之g的自舆w移功能，@p少了Y料w移r的工作量，但是p失一
定rg。如果各Y料熘g的Y料w移K非自舆M行，你就必自行完成w移工
作，@工作量可是很大的。@N情r下你必更加留神classes 鹊馁Y料Y
化。你仍然可以放心classes 的行檗D移^去，但D移谖唬field）r就必格
外小心。Y料尚未被D移前你就得先\用存取函式（accessors）造成「Y料已D
移」的假象。一旦你_定知道「Y料在何」r，就可以一次性地①Y料w
第2 章 重原t
Refactoring C Improving the Design of Existing Code
64
移^去。@r惟一需要修改的只有存取函式（accessors），@也降低了e`LU。
修改介面（Changing Interfaces）
P於物件，另一件重要事情是：它允S你分_修改w模M的作
（implementation）和介面（interface）。你可以安全地修改某物件炔慷不影他
人，但於介面要特e慎 ― 如果介面被修改了，任何事情都有可能l生。
一直χ砝_的一件事就是：S多重手法的_修改介面。像Rename
Method（273）@N蔚闹手法所做的一切就是修改介面。@O檎滟F的封
b概念硎颤N影呢？
如果某函式的所有呼叫幼鞫荚谀愕目刂浦下，那N即使修改函式名Q也不
有任何}。哪怕面σpublic 函式，只要能取得K修改其所有呼叫者，你也
可以安心地⑦@函式易名。只有需要修改的介面S被那些「找不到，即使找
到也不能修改」的程式a使用r，介面的修改才成}。如果情r真是如此，
我就f：@介面是「已l呀槊妗梗published interface）― 比公_介面（public
interface）更M一步。介面一旦l眩你就再也o法HH修改呼叫者而能虬踩地
修改介面了。你需要一略檠}s的程序。
@想法改了我的}。如今的}是：如何面δ切┍仨修改「已l
介面」的重手法？
言之，如果重手法改了已l呀槊妫published interface），你必同rSo
新f介面，直到你的所有用舳加rg@化做出反。幸\的是@不
太困y。你通常都有k法把事情M好，f介面^m工作。量@N做：
f介面呼叫新介面。你要修改某函式名Qr，留下f函式，它呼叫新函
式。千f不要拷函式作a，那你陷入「重}程式a」（duplicated code）
的泥淖中y以自拔。你使用Java 提供的 deprecation（反Γ┰O施，⑴f介
面擞 "deprecated"。@N一砟愕暮艚姓呔注意到它了。
@^程的一好例子就是Java 容器e（群集e，collection classes）。Java 2
的新容器取代了原先一些容器。Java 2 容器lr，JavaSoft 花了很大力
_l者提供一l利w徙之路。
「保留f介面」的k法通常可行，但很┤恕Ｆ鸫a在一段rge你必建造（build）
KSo一些~外的函式。它使介面得}s，使介面y以使用。好我有
另一x瘢翰灰l眩publish）介面。然我不是f要完全禁止，因楹苊黠@
2.5 重的y}
Refactoring C Improving the Design of Existing Code
65
你必得l岩恍┙槊妗Ｈ绻你正在建造供外部使用的APIs，像Sun 所做的那樱
肯定你必得l呀槊妗Ｎ抑所以f量不要l眩是因槲页３？吹揭恍╅_lF
公_了太多介面。我曾看到一支三人F@N工作：每人都向另外扇斯
_l呀槊妗＿@使他不得不常砘鼐So介面，而其他原本可以直接M入
程式欤行修改自己管理的那一部分，那pS多。^度{「程式a碛
唷沟F常常犯@Ne`。l呀槊婧苡杏茫但也有代r。所以除非真有必
要，el呀槊妗＿@可能意味需要改你的程式a碛嘤^念，每人都可以
修改e人的程式a，以\介面的改印Ｒ源n（成Γ┚程（Pair Programming）
完成@一切通常是好主意。
不要^早l眩published）介面。修改你的程式a碛嗾策，使重更场
Java之中有一特eP於「修改介面」的}：在throws 子句中增加一常。
@K不是κ鹈式（signature）的修改，所以你o法以delegation（委手法）涵
w它。但如果用舫淌酱a不做出相修改，g器不它通^。@}很y
解Q。你可以檫@函式x褚新名字，f函式呼叫它，K⑦@新增的
checked exception（可控式常）DQ成一unchecked exception（不可控常）。
你也可以出一unchecked 常，不^@幽憔失去z能力。如果你那N
做，你可以警告呼叫者：@unchecked 常日後成一checked 常。@
铀就有rg在自己的程式a中加上Υ水常的理。出於@原因，我是
喜g檎package定x一superclass常（就像java.sql的SQLException），
K_保所有public 函式只在自己的throws 子句中宣告@常。@游揖涂梢噪S
心所欲地定xsubclass 常，不影呼叫者，因楹艚姓哂肋h只知道那更具
一般性的superclass 常。
y以藉由重手法完成的O改
透^重，可以排除所有Oe`幔渴欠翊嬖谀承┖诵脑OQ策，o法以重
手法修改？在@I域e，我的y尚不完整。然某些情r下我可以
很有效地重，@常常令我倍感@，但的_也有y以重的地方。比如f在
一０钢校我很y（但是有可能）「o安全需求（no security requirements）
情r下造起淼南到y」重椤赴踩性良好的（good security）系y」。
@N情r下我的k法就是「先想像重的情r」。考]候xO方案r，我
自己：⒛O重榱硪O的y度有多大？如果看上去很危我就不
第2 章 重原t
Refactoring C Improving the Design of Existing Code
66
必太心x袷欠竦卯，於是我就x最蔚脑O，哪怕它不能涵w所有在
需求也]PS。但如果A先看不到蔚闹k法，我就在O上投入更多力
狻２贿^我lF，@N情r很少出F。
何r不重？
有r候你根本不重 ― 例如你重新所有程式a的r候。有r候
既有程式a在太混y，重它不如重新一淼煤巍Ｗ龀鲞@NQ定很困
y，我承J我也]有什N好t可以判嗪r放重。
重（而非重）的一清楚就是：F有程式a根本不能正常\作。你可能
只是著做cy，然後就lF程式a中M是e`，根本o法定\作。住，
重之前，程式a必起a能蛟诖蟛糠智r下正常\作。
一折衷k法就是：「大K^w」重椤阜庋b良好的小型M件」。然後你
就可以逐一M件作出「重或重建」的Q定。@是一H具希望的k法，但我
]有足，所以也o法出秀的指гt。於一重要的古老系y，
@肯定是一很好的方向。
另外，如果０敢呀最後期限，你也避免重。在此rC，闹^程A得
的生a力只有在最後期限^後才能wF出恚而那r候已r不我予。Ward
Cunningham Υ擞幸很好的看法。他把未完成的重工作形容椤铡埂：
多公司都需要借硎棺约焊有效地\D。但是借就得付利息，^於}s的程
式a所造成的「So和U展的~外_N」就是利息。你可以承受一定程度的利息，
但如果利息太高你就被嚎濉０展芾砗檬呛苤匾的，你Sr藉由重
一部分铡
如果０敢呀非常接近最後期限，你不再分心於重，因橐呀]有rg了。
不^多０附@示：重的_能蛱岣呱a力。如果最後你]有足rg，
通常就表示你其早M行重。
2.6 重cO
「重」肩一特e任眨核和O彼此互a。初W程的r候，我埋^就
程式，噩噩地M行_l。然而很快我便lF，「事先O」（upfront design）
可以助我省回^工的高昂成本。於是我很快加@N「A先O」L格。S多
2.6 重cO
Refactoring C Improving the Design of Existing Code
67
人都把O看作w_l的PIh，而把程（programming）看作只是C械式
的低印ＫJ樵O就像工程D而撰a就像施工。但是你要知道，w
和真器械有著很大的差。w的可塑性更，而且完全是思想a品。正如Alistair
Cockburn所f：『有了O，我可以思考更快，但是其中充M小漏洞。』
有一N^cJ椋褐可以成椤割A先O」的替代品。@意思是你根本不必做
任何O，只管按照最初想法_始a，程式a有效\作，然後再⑺重成
型。事上@Nk法真的可行。我的_看^有人@N做，最後@得O良好的
w。O限程（Extreme Programming）[Beck, XP] 的支持者O力提倡@Nk法。
管如上所言，只\用重也能收到效果，但@K不是最有效的途健Ｊ堑模即
使O限程（Extreme Programming）酆谜咭M行A先O。他使用CRC
卡或似的|西z各N不同想法，然後才得到第一可被接受的解Q方案，
然後才能_始撰a，然後才能重。PI在於：重改了「A先O」的角色。
如果]有重，你就必保C「A先O」正_o`，@毫μ大了。@意味
如果硇枰υ始O做任何修改，代r都⒎浅８甙骸Ｒ虼四阈枰把更多r
g和精力放在A先O上，以避免日後修改。
如果你x裰，}的重c就D了。你仍然做A先O，但是不必一定找出
正_的解Q方案。此刻的你只需要得到一足蚝侠淼慕Q方案就蛄恕Ｄ愫芸
定地知道，在F@初始解Q方案的r候，你}的理解也逐u加深，你
可能察X最佳解Q方案和你初O想的有些不同。只要有重@武器在手，
就不成}，因橹日後的修改成本不再高昂。
@NDе乱重要Y果：wO朝向化前M了一大步。^去未曾\用重
r，我是力求得到`活的解Q方案。任何一需求都我提心吊地猜疑：
在系y勖期g，@需求е略拥淖化？由於更O的代r非常高昂，
所以我希望建造一足蜢`活、足固的解Q方案，希望它能承受我所能A
的所有需求化。}在於：要建造一`活的解Q方案，所需的成本y以估算。
`活的解Q方案比蔚慕Q方案}sS多，所以最K得到的w通常也更y
So ― m然它在我A先O想的方向上的_是更加`活。就算幸\走在A先O想
的方向上，你也必理解如何修改O。如果化只出F在一地方，那不算
大}。然而化其可能出F在系y各。如果在所有可能的化出F地c都
建立起`活性，整系y的}s度和Soy度都大大提高。然，如果最後l
F所有@些`活性都毫o必要，@才是最大的失　Ｄ阒道，@其中肯定有些`
第2 章 重原t
Refactoring C Improving the Design of Existing Code
68
活性的_派不上用觯但你so法Ay到底是哪些派不上用觥榱双@得自己想
要的`活性，你不得不加入比H需要更多的`活性。
有了重，你就可以通^一l不同的途付化淼娘LU。你仍f需要思
考在的化，仍f需要考]`活的解Q方案。但是你不必再逐一F@些解Q
方案，而是自己：『把一蔚慕Q方案重成@`活的方案有多
大y度？』如果答案是「相容易」（大多r候都如此），那N你就只需F
目前的畏桨妇托辛恕
重可以砀蔚脑O，同r又不p失`活性，@也降低了O^程的y度，
pp了O毫ΑＲ坏χ淼暮涡杂懈多感受，你甚至可以不必再A先
思考前述所^的`活方案 ― 一旦需要它，你有足虻男判娜ブ。是的，
下只管B可绦械淖詈化系y，至於`活而}s的O，唔，多r候你都不
需要它。
诙o@
― Ron Jeffries
Chrysler Comprehensive Compensation（克R斯勒C合薪Y系y）的支付^程太慢了。
m然我的_l]Y束，@}s已_始困_我，因樗已拖累了y速
度。
Kent Beck、Martin Fowler 和我Q定解Q@}。等待大夥合的rge，{著我
@系y的全P了解，我_始推y：到底是什N系y慢了？我想到捣N可能，
然後和夥伴了追N可能的修改方案。最後，P於「如何@系y绦懈快」，
我提出了一些真正的好c子。
然後，我拿Kent 的量y工具度量了系y效率。我一_始所想的可能性竟然全都不是
}肇因。我lF：系y把一半rg用建「日期」w（instance）。更有趣的
是，所有@些w都有相同的值。
於是我^察日期的建，lF有C⑺最佳化。日期原本是由字串DQ而生，
即使o外部入也是如此。之所以使用字串DQ方式，完全是榱朔奖沔IP入。好，
也S我可以⑺最佳化。
於是我^察日期怎颖贿@程式\用。我lF，很多日期物件都被用懋a生「日
期^g」w（instance）。「日期^g」是物件，由一起始日期和一Y束日期
M成。仔追下去，我lF^大多等掌^g是空的！
理日期^gr我遵循@右t：如果Y束日期在起始日期之前，@日期^
g就是空的。@是一l很好的t，完全符合@class 的需要。裼么艘灰t後不
2.7 重c效率/性能（Performance）
Refactoring C Improving the Design of Existing Code
69
久，我意R到，建一「起始日期在Y束日期之後」的日期^g，仍然不算是清
晰的程式a，於是我把@行樘到一factory method（g]：一著名的O
式，《Design Patterns》），由它ｉT建「空的日期^g」。
我做了上述修改，使程式a更加清晰，s意外得到了一@喜。我建一固定
不的「空日期^g」物件，K上述{整後的factory method 每次都骰卦物件，
而不再每次都建新物件。@一修改把系y速度提N了缀跻槐叮足以y速度_
到可接受程度。@只花了我大s五分。
我和F成T（Kent 和Martin x^⒓樱┱J真推y^：我t若指掌的@程式中可
能有什Ne`？我甚至{空做了些改MO，s]有先ο到y的真情rM行量y。
我完全e了。除了一龊苡腥さ慕徽，我什N好事都]做。
教：哪怕你完全了解系y，也H量y它的效率，不要臆y。臆y你W到一
些|西，但十有八九你是e的。
2.7 重c效率/性能（Performance）
g]：在我的接|中，performance一~被不同的人予以不同的解和J知：效率、
性能、效能。不同地^（例如_澈痛箨）的T用法亦不相同。本一遇performance
我便g樾率。efficient g楦咝Вeffectiveg橛行А
P於重，有一常被提出的}：它Τ淌降男率⒃斐稍拥挠绊？榱俗
w易於理解，你常作出一些使程式绦凶慢的修改。@是重要的}。我
K不成榱颂岣咴O的性或把希望寄於更快的硬w身上，而忽略了程式
效率。已有很多w因樗俣忍慢而被用艟芙^，日益提高的C器速度亦只不
^略微放了速度方面的限制而已。但是，Q角度f，m然重必然使w
绦懈慢，但它也使w的效率最佳化更易M行。除了π率有栏褚求的即r
（real time）系y，其他任何情r下「快速w」的秘密就是：首先出可{
（tunable）w，然後{整它以求@得足蛩俣取
我看^三N「快速w」的方法。其中最栏竦氖恰rgA算法」（time
budgeting），@通常只用於效率要求O高的即r系y。如果使用@N方法，分解
你的Or就要做好A算，o每M件A先分配一定Y源 ― 包括rg和绦熊
E（footprint）。每M件^Σ荒艹出自己的A算，就算碛小缚稍诓煌M件之
g{度A配rg」的C制也不行。@N方法高度重效率，於心律{器一
的系y是必的，因樵谶@拥南到y中t淼就是e`的。但ζ渌
系y（例如我常_l的企IY系y）而言，如此追求高效率就有c^份了。
第2 章 重原t
Refactoring C Improving the Design of Existing Code
70
第二N方法是「持mP切法」（constant attention）。@N方法要求任何程式T在
任何rg做任何事r，都要O法保持系y的高效率。@N方式很常，感X上很
有吸引力，但通常不起太大作用。任何修改如果是榱颂岣咝率，通常使程
式y以So，因而p_l速度。如果最K得到的w的_更快了，那N@cp
失尚有所值，可惜通常事c`，因樾率改善一旦被分散到程式各角落，每次
改善都只不^是摹Τ淌叫榈囊M隘角」出l而已。
P於效率，一件很有趣的事情是：如果你Υ蠖党淌竭M行分析，你lF它把
大半rg都耗M在一小半程式a身上。如果你一同仁地最佳化所有程式a，90%
的最佳化工作都是白M海因楸荒阕罴鸦的程式a有S多y得被绦衅怼
你花rg做最佳化是榱俗程式绦懈快，但如果因槿狈Τ淌降那宄JR而
花Mrg，那些rg都是被浪M掉了。
第三N效率提N法S利用上述的 "90%" y。裼眠@N方法r，你以一N「良
好的分解方式」（well-factored manner）斫ㄔ熳约旱某淌剑不π率投以任何P
切，直至M入效率最佳化A段 ― 那通常是在_l後期。一旦M入A段，你再
按照某特定程序碚{整程式效率。
在效率最佳化A段中，你首先以一量y工具O控程式的绦校它告V你
程式中哪些地方大量消耗rg和空g。@幽憔涂梢哉页鲂率狳c（hot spot）所
在的一小段程式a。然後你集中P切@些狳c，K使用前述「持mP切法」
中的最佳化手段碜罴鸦它。由於你把注意力都集中在狳c上，^少的工作量
即可@F^好的成果。即便如此你是必保持慎。和重一樱你小幅
度修改。每走一步都需要g、y、再次量y。如果]能提高效率，就撤
N此次修改。你^m@「lF狳c、去除狳c」的^程，直到@得客M
意的效率橹埂ｊP於@技g，McConnell [McConnell] 槲提供了更多Y。
一被良好分解（well-factored）的程式可煞矫椭此N最佳化形式。首先，
它你有比^充裕的rgM行效率{整（performance tuning），因橛蟹纸饬己
的程式a在手，你就能蚋快速地添加功能，也就有更多rg用在效率}上（
_的量yt保C你把@些rg投Y在恰地c）。其次，面Ψ纸饬己玫某淌剑
你在M行效率分析r便有^的粒度（granularity），於是量y工具把你入
^小的程式段落中，而效率的{整也比^容易些。由於程式a更加清晰，因此你
能蚋好地理解自己的x瘢更清楚哪N{整起PI作用。
我lF重可以椭我出更快的w。短程看恚重的_使w慢，但
它使最佳化A段中的w效率{整更容易。最K我是有^。
2.8 重起源何？
Refactoring C Improving the Design of Existing Code
71
2.8 重起源何？
我曾努力想找出重（refactoring）一~的真正起源，但最K失×恕秀程式
T肯定至少花一些rg砬謇碜约旱某淌酱a。@N做是因椋他知道的
程式a比syo章的程式a更容易修改，而且他知道自己缀o法一_始就
出的程式a。
重不止如此。本中我把重看作整w_l^程的一PIh。最早J
R重重要性的人是Ward Cunningham和Kent Beck，他早在1980s 之前就
_始使用Smalltalk，那是特em合重的h境。Smalltalk 是一十分B的h
境，你可以很快出O具功能的w。Smalltalk 的「g/BY/绦小惯L期非常短，
因此很容易快速修改程式a。它是物件向，所以也能蛱峁大工具，最大限
度地⑿薷牡挠绊[藏於定x良好的介面背後。Ward 和Kent 努力l展出一套m
合@h境的w_l程序（如今Kent 把@NL格叫作O限程 [Beck, XP]）。
他意R到：重於提高他的生a力非常重要。哪r起他就一直在工作
中\用重技g，在烂C而J真的w０钢惺褂盟，K不嗑@程序。
Ward 和Kent 的思想Smalltalk 社群a生了O大影，重概念也成Smalltalk
文化中的一重要元素。Smalltalk 社群的另一位I袖是Ralph Johnson，伊利Z大
W班{分校教授，著名的「四巨^」3[Gang of Four] 之一。Ralph 最大的d趣
之一就是_lw框架（framework）。他揭示了重於`活高效框架的_l
助。
Bill Opdyke 是Ralph的博士班W生，框架也很感d趣。他看到重的在r值，
K看到重用於Smalltalk 之外的其他Z言的可能性。他的技g背景是交Q
系y的_l。在@N系y中，大量的}s情rcr俱增，而且非常y以修改。Bill
的博士研究就是墓ぞB者的角度砜创重。通^研究，Bill lF：在C++
framework _l案中，重很有用。他也研究了O有必要的「Z意保持性
（semantics-preserving）重」及其C明方式，以及如何以工具F重。r至今
日，Bill 的博士文 [Opdyke] 仍然是重I域中最有r值、最ST的研究成果。
此外他楸撰了第13章。
3 g]：Ralph Johnson 和另外三位先生Erich Gamma, Richard Helm, John Vlissides 合
了w_l界Y名的《Design Patterns》，人Q四巨^（Gang of Four）。
第2 章 重原t
Refactoring C Improving the Design of Existing Code
72
我得1992 年OOPSLA 大上到Bill 的情景。我坐在一g咖啡de，
r我正楸＝IB的一概念框架（conceptual framework）中的某些工
作。Bill 跟我起他的研究成果，我得自己r的想法：『有趣，但K非真的
那N重要』。唉，我完全e了。
John Brant和Don Roberts⒅中的「工具」想lP光大，_l了一名椤钢
g[器」（Refactoring Browser）的Smalltalk 重工具。他撰了本第14
章，其中χ工具做了更多介B。
那N，我呢？我一直有清理程式a的A向，但]有想到@有那N重要。後
砦液Kent 一起做了案子，看到他使用重手法，也看到重ιa效率和a
品品|淼挠绊。@份w我相信：重是一T非常重要的技g。但是，在
重的W和推V^程中我遇到了挫折，因槲夷貌怀鋈魏我槐o程式T看，
也]有任何一位＜掖蛩出@右槐。所以，在@些＜业椭下，我下
了@本。
最佳化一薪Y系y
― Rich Garzaniti
Chrysler Comprehensive Compensation（克R斯勒C合薪Y系y）交oGemStone 公
司之前，我用了相L的rg_l它。_l^程中我o可避免地lF程式不蚩欤
於是找了Jim Haungs ― GemSmith 中的一位好手 ― 他臀最佳化@系y。
Jim 先用一crg他的F了解系y\作方式，然後以GemStone 的ProfMonitor 特
性出一效率量y工具，⑺插入我的功能y中。@工具可以@示系ya
生的物件盗浚以及@些物件的Q生c。
令我吃@的是：建量最大的物件竟是字串。其中最大的工作量t是反覆a生
12,000-bytes 的字串。@很特e，因檫@字串在太大了，BGemStone T用的垃圾回
收O施都o法理它。由於它是如此巨大，每被建出恚GemStone 都⑺分
（paging）至磁碟上。也就是f字串的建竟然用上了I/O 子系y（g]：分C制
佑I/O），而每次出r都要a生@拥淖执三次u
我的第一解Qk法是把一12,000-bytes 字串快取（cached）起恚@可解Q一大
半}。後砦又加以修改，⑺直接入一file stream，亩避免a生字串。
解Q了「巨大字串」}後，Jim 的量y工具又lF了一些似}，只不^字串稍微
小一些：800-bytes、500-bytes…等等，我也都λ改用file stream，於是}都解
Q了。
使用@些技g，我步提高了系y效率。_l^程中原本似乎需要1,000 小r以上才
2.8 重起源何？
Refactoring C Improving the Design of Existing Code
73
能完成的薪Y算，H\作r只花40 小r。一月後我把rgs短到18 小r。
正式投入\Dr只花12小r。^一年的绦泻透纳漆幔全部算只需9 小r。
我的最大改M就是：⒊淌椒旁诙嗵理器（multi-processor）算C上，以多w（multiple
threads）方式绦小Ｗ畛踹@系yK非按照多w思S碓O，但由於程式a有良好分
解（well factored），所以我只花三天rg就它得以同r绦卸绦芯w了。F在，
薪Y的算只需2小r。
在Jim提供工具使我得以在H操作中量度系y效率之前，我也猜y^}所在。
但如果只靠猜y，我需要很L的rg才能出真正的解法。真的量y指出了一
完全不同的方向，K大大加快了我的M度。
Refactoring C Improving the Design of Existing Code
74
Refactoring C Improving the Design of Existing Code
75
第3 章 程式a的奈兜3
程式a的奈兜
Bad smells in Code, by Kent Beck and Martin Fowler
If it stinks, change it.（如果尿布臭了，就Q掉它）
― Z出Beck奶奶，小孩狃B哲W
F在，於「重如何\作」，你已有了相好的理解。但是知道How 不代表
知道When。Q定何r重、何r停止，和知道重C制如何\D是一又匾的。
y}砹耍〗忉「如何h除一instance 怠够颉溉绾萎a生一class hierarchy
（A芋w系）」很容易，因檫@些都是很蔚氖虑椤５要解「在什Nr候
做@些幼鳌咕]那N理成章了。除了露资趾混的程美W（f，@就
是咱@些常做的事），我希望某些|西更具f服力一些。
去K黎士拜LKent Beck的r候，我正在檫@微妙的}大X筋。也S是因
受到出生的女旱馕队绊吧，他提出「用味道硇稳葜rC」。『味道』，
他f，『起硎遣皇潜群混的美W理要好多了？』啊，是的。我看^很多
很多程式a，它所俚０拇螳@成功到奄奄一息都有。^察@些程式ar，
我W了闹姓つ承┨囟Y，@些Y指出（有r甚至就像尖叫呼喊）重
的可能性。（本章主~Q成「我」，是榱朔从骋事：Kent 和我共同撰
本章。你可以看出我z的文P差 ― 插科打的部分是我的，其N都
是他的。）
我K不Do你一「重r晚矣」的精_衡量省奈的看恚
]有任何量度矩比得上一RV博者的直X。我只告V你一些E象，它
指出「@e有一可使用重解Q的}」。你必培B出自己的判嗔ΓW
判嘁class 扔卸嗌instance 邓闶翘大、一函式扔卸嗌傩谐淌酱a才
算太L。
第3 章 程式a的奈兜
Refactoring C Improving the Design of Existing Code
76
如果你o法_定M行哪一N重手法，x本章热莺头獾软表格ふ
`感。你可以x本章（或快速g[封底软表格）砼嘧约郝到的是什N味
道，然後再看看我所建h的重手法能否椭你。也S@e所列的「臭味l款」
和你所zy的不M相符，但它能槟阒敢正_方向。
3.1 Duplicated Code（重}的程式a）
臭味行列中首其n的就是Duplicated Code。如果你在一以上的地c看到相同
的程式Y，那N可肯定：O法⑺合而橐唬程式得更好。
最渭的Duplicated Code 就是「同一class 鹊函式含有相同算式
（expression）」。@r候你需要做的就是裼Extract Method（110）提出重}
的程式a，然後@地c都呼叫被提出淼哪且欢纬淌酱a。
另一N常情r就是「互樾值埽sibling）的subclasses 群相同算式」。要
避免@N情r，只需classes 都使用Extract Method（110），然後再Ρ惶
出淼某淌酱a使用Pull Up Method（332），⑺推入superclass 取Ｈ绻程式a
之g只是似，K非完全相同，那N就得\用Extract Method（110）⑾嗨撇糠
和差部分割_，成为一函式。然後你可能lF或S可以\用Form Template
Method（345）@得一Template Method O式。如果有些函式以不同的演
算法做相同的事，你可以穸ㄆ渲休^清晰的一，K使用Substitute Algorithm
（139）⑵渌函式的演算法替Q掉。
如果毫不相P的classes 瘸霈FDuplicated Code，你考]ζ渲幸使
用Extract Class（149），⒅匮}程式a提到一立class 中，然後在另一class
仁褂眠@新class。但是，重}程式a所在的函式也可能的_只凫赌
class，另一class只能呼叫它，抑或@函式可能凫兜谌class，而另classes
引用@第三class。你必Q定@函式放在哪鹤詈线m，K_保它被安置
後就不再在其他任何地方出F。
3.2 Long Method（^L函式）
碛小付毯式」（short methods）的物件活得比^好、比^L。不熟悉物件向
技g的人，常常X得物件程式中只有oFoM的delegation（委），根本]有M
行任何算。和此程式共同生活的曛後，你才知道，@些小小函式有多大
r值。「g接印顾能淼娜部利益 ― 解能力、共享能力、x衲芰 ― 都
3.2 Long Method（^L函式）
Refactoring C Improving the Design of Existing Code
77
是由小型函式支援的（看p.61 的「g接雍椭」）。
很久以前程式T就已JR到：程式愈L愈y理解。早期的程Z言中，「子程式
叫用幼鳌剐枰~外_N，@使得人不太芬馐褂small method。F代OOZ言
缀跻呀完全免除了行程（process）鹊摹负式叫用幼黝~外_N」。不^程式
ax者是得多M力猓因樗必常DQ上下文去看看子程式做了什N。
某些_lh境允S使用者同r看到函式，@可以椭你省去部分麻，但是
small method 容易理解的真正PI在於一好名字。如果你能o函式起好名
字，x者就可以通^名字了解函式的作用，根本不必去看其中了些什N。
最K的效果是：你更eOM取地分解函式。我遵循@右l原t：每感
X需要以]碚f明c什N的r候，我就把需要f明的|西M一立函式
中，K以其用途（而非F手法）命名。我可以σ唤M或甚至短短一行程式a
做@件事。哪怕替Q後的函式呼叫幼鞅群式本身L，只要函式名Q能蚪忉
其用途，我也毫不q豫地那N做。PI不在於函式的L度，而在於函式「做
什N」和「如何做」之g的Z意距x。
百分之九十九的龊涎e，要把函式小，只需使用Extract Method（110）。找到
函式中m合集在一起的部分，⑺提出硇纬梢新函式。
如果函式扔写罅康岛r担它δ愕暮式提形成阻K。如果你
L\用Extract Method（110），最K就把S多@些岛r诞做担
鬟fo被提出淼男潞式，е驴勺x性缀]有任何提N。啊是的，你可以
常\用Replace Temp with Query（120）硐除@些r元素。Introduce Parameter
Object（295）和Preserve Whole Object（288）t可以⑦^L的盗凶得更
一些。
如果你已@N做了，仍然有太多r岛担那就使出我的⑹拄澹
Replace Method with Method Object（135）。
如何_定提哪一段程式a呢？一很好的技巧是：ふ以]。它通常是指
出「程式a用途和F手法g的Z意距x」的信。如果程式a前方有一行]，
就是在提醒你：可以⑦@段程式a替Q成一函式，而且可以在]的基A上o
@函式命名。就算只有一行程式a，如果它需要以]碚f明，那也值得⑺
提到立函式去。
l件式和圈常常也是提的信。你可以使用Decompose Conditional（238）
理l件式。至於圈，你⑥圈和其鹊某淌酱a提到一立函式中。
第3 章 程式a的奈兜
Refactoring C Improving the Design of Existing Code
78
3.3 Large Class（^大e）
如果想利用我class 做太多事情，其韧往就出F太多instance 怠Ｒ坏┤
此，Duplicated Code 也就接踵而至了。
你可以\用Extract Class（149）狄黄鹛至新class 取Ｌrx
class 缺舜讼嚓P的担⑺放在一起。例如 "depositAmount" 和
"depositCurrency" 可能`偻一class。通常如果class 鹊涤
著相同的字首或字尾，@就意味有C把它提到某M件取Ｈ绻@M件
m合作橐subclass，你lFExtract Subclass（330）往往比^巍
有r候class K非在所有r刻都使用所有instance 怠９真如此，你或S可以多
次使用Extract Class（149）或Extract Subclass（330）。
和「太多instance 怠挂樱class 热绻有太多程式a，也是「程式a重}、
混y、死亡」的^佳滋生地c。最蔚慕Q方案（得幔我喜g蔚
解Q方案）是把N的|西消弭於class 炔俊Ｈ绻有五「百行函式」，它之
中很多程式a都相同，那N或S你可以把它成五「十行函式」和十提
出淼摹鸽p行函式」。
和「碛刑多instance怠挂樱一class 如果碛刑多程式a，往往也m合
使用Extract Class（149）和Extract Subclass（330）。@e有有用技巧：先_
定客舳巳绾问褂盟，然後\用Extract Interface（341）槊恳环N使用方式提
出一介面。@或S可以椭你看清楚如何分解@class。
如果你的Large Class 是GUI class，你可能需要把Y料和行橐频揭立的
I域物件（domain object）去。你可能需要蛇各保留一些重}Y料，K令@些Y
料同步（sync.）。Duplicate Observed Data（189）告V你怎N做。@N情r下，
特e是如果你使用f式Abstract Windows Toolkit（AWT）M件，你可以裼眠@N
方式去掉GUI class K代以SwingM件。
3.4 Long Parameter List（^L盗校
_始W程的r候，老教我：把函式所需的所有|西都以鬟fM去。
@可以理解，因槌此之外就只能x袢域Y料，而全域Y料是邪旱|西。物
件技g改了@一情r，因槿绻你手上]有你所需要的|西，可以叫另一
3.5 Divergent Change（l散式化）
Refactoring C Improving the Design of Existing Code
79
物件o你。因此，有了物件，你就不必把函式需要的所有|西都以鬟fo它
了，你只需鹘o它足虻|西、函式能闹蝎@得自己需要的所有|西就行了。
函式需要的|西多半可以在函式的宿主e（host class）中找到。物件向程式
中的函式，其盗型ǔ１仍鹘y程式中短得多。
@是好F象，因樘L的盗须y以理解，太多造成前後不一致、不易使
用，而且一旦你需要更多Y料，就不得不修改它。如果⑽锛鬟fo函式，大多
敌薷亩]有必要，因槟愫芸赡苤恍瑁ㄔ诤式龋┰黾右l求（requests），
就能得到更多Y料。
如果「向既有物件l出一l求」就可以取得原本位於盗猩系囊环葙Y料，那
N你又tReplace Parameter with Method（292）。上述的既有物件
可能是函式所class 鹊囊Y料冢field），也可能是另一怠Ｄ氵可以
\用Preserve Whole Object（288）碜酝一物件的一堆Y料收集起恚K以
物件替Q它。如果某些Y料缺乏合理的物件w伲可使用Introduce Parameter
Object（295）樗u造出一「滴锛」。
此g存在一重要的例外。有r候你明@不希望造成「被叫用之物件」c「^大
物件」g的某N依存PS。@r候①Y料奈锛中拆解出为作担也很
合情合理。但是注意其所引l的代r。如果盗刑L或化太l繁，你就需
要重新考]自己的依存Y（dependency structure）了。
3.5 Divergent Change（l散式化）
我希望w能蚋容易被修改 ― 竟w再怎Nf本砭驮是「」的。一
旦需要修改，我希望能蛱到系y的某一c，只在作修改。如果不能做到
@c，你就嗅出煞No密相P的刺鼻味道中的一N了。
如果某class常因椴煌的原因在不同的方向上l生化，Divergent Change
就出F了。你看著一class f：『呃，如果新加入一Y料欤我必修改@
三函式；如果新出F一N金融工具，我必修改@四函式』，那N此r也S
⑦@物件分成更好，@N一砻物件就可以只因一N化而需要修改。
然，往往只有在加入新Y料旎蛐陆鹑诠ぞ哚幔你才能lF@一c。δ骋
外界化的所有相修改，都只l生在我class 中，而@新class 鹊乃
有热荻反外界化。榇耍你找出因著某特定原因而造成的所有
化，然後\用Extract Class（149）⑺提到另一class 中。
第3 章 程式a的奈兜
Refactoring C Improving the Design of Existing Code
80
3.6 Shotgun Surgery（霰式修改）
Shotgun Surgery似Divergent Change，但恰恰相反。如果每遇到某N化，
你都必在S多不同的classes 茸鞒鲈S多小修改以回之，你所面R的奈兜谰
是Shotgun Surgery。如果需要修改的程式a散阉奶，你不但很y找到它，
也很容易忘某重要的修改。
@N情r下你使用Move Method（142）和Move Field（146）把所有需要修改
的程式a放M同一class。如果眼下]有合m的class 可以安置@些程式a，就
造一。通常你可以\用Inline Class（154）把一系列相P行榉胚M同一class。
@可能造成少量Divergent Change，但你可以p易理它。
Divergent Change 是指「一class 受多N化的影」，Shotgun Surgery t
是指「一N化引l多classes 相修改」。@煞N情r下你都希望整理程式
a，取得「外界化」c「待改e」呈F一σ魂PS的理想境地。
3.7 Feature Envy（依偾榻Y）
物件技g的全部要c在於：@是一N「①Y料和加T其上的操作行榘b在一起」
的技g。有一N典馕妒牵汉式δclass 的d趣高^ψ约核之host class
的d趣。@N孺慕之情最通常的焦c便是Y料。o荡谓e，我看到某函
式榱擞算某值，牧硪物件那汉艚缀醢氪虻娜≈岛式（getting method）。
法@而易：把@函式移至另一地c。你使用Move Method（142）把
它移到它去的地方。有r候函式中只有一部分受@N依僦苦，@r候你
使用Extract Method（110）把@一部分提到立函式中，再使用Move Method
（142）它去它的糁屑@。
然，K非所有情r都@N巍Ｒ函式往往用上classes 特性，那N它
究竟被置於何呢？我的原t是：判嗄class 碛凶疃唷副淮撕式使用」
的Y料，然後就把@函式和那些Y料[在一起骸Ｈ绻先以Extract Method（110）
⑦@函式分解^小函式K分e置放於不同地c，上述步E也就比^容易
完成了。
有}s精巧的式（patterns）破牧诉@t。f起@}，「四巨^」 [Gang
of Four] 的Strategy和Visitor立刻跳入我的X海，Kent Beck的Self Delegation
[Beck] 也在此列。使用@些式是榱抗奈兜Divergent Change。最根本的
原t是：⒖是一起化的|西放在一K骸！纲Y料」和「引用@些Y料」的行
3.8 Data Clumps（Y料泥F）
Refactoring C Improving the Design of Existing Code
81
榭是一起化的，但也有例外。如果例外出F，我就搬移那些行椋保持「
化只在一地l生」。Strategy 和Visitor 使你得以p修改函式行椋因樗
少量需被覆（overridden）的行楦綦x_ ― 然也付出了「多一娱g接性」
的代r。
3.8 Data Clumps（Y料泥F）
Y料（data items）就像小孩子：喜g成群Y地待在一K骸Ｄ愠３？梢栽诤
多地方看到相同的三或四PY料：classes 鹊南嗤谖唬field）、S多函
式署名式（signature）中的相同怠＿@些「是在一起出F的Y料」真放
M凫端自己的物件中。首先找出@些Y料的谖恍问剑field）出Fc，\
用Extract Class（149）⑺提到一立物件中。然後⒆⒁饬D移到函式
署名式（signature）上^，\用Introduce Parameter Object（295）或Preserve Whole
Object（288）樗p肥。@N做的直接好是可以⒑芏盗锌s短，化函式
呼叫幼鳌Ｊ堑模不必因Data Clumps 只用上新物件的一部分谖欢在意，只
要你以新物件取代（或更多）谖唬你就值回票r了。
一好的u噢k法是：h掉多Y料中的一P。其他Y料有]有因而失去意x？
如果它不再有意x，@就是明_信：你樗a生一新物件。
s短谖岛担然可以去除一些奈兜溃但更重要的是：一旦碛
新物件，你就有C程式散l出一N芳香。得到新物件後，你就可以著手ふ
Feature Envy，@可以湍阒赋觥缚梢浦列class」中的NN程式行椤２槐靥久，
所有classes都⒃谒的小小社中充分l]自己的生a力。
3.9 Primitive Obsession（基本型e偏蹋
大多稻程h境都有煞NY料：Y型e（record types）允S你①Y料M成有
意x的形式；基本型e（primitive types）t是成Y型e的e木K。Y是
硪欢ǖ念~外_N。它有c像Y料熘械谋砀瘢或是那些得不失（只
做一杉事而建，s付出太大~外_N）的|西。
物件的一O具r值的|西是：它模糊（甚至打破）了M於基本Y料和we
^大的classes 之g的界限。你可以p出一些cZ言冉ǎ基本）型eo
的小型classes。例如Java就以基本型e表示抵担而以class 表示字串和日期 ― @
型e在其他S多程h境中都以基本型e表F。
第3 章 程式a的奈兜
Refactoring C Improving the Design of Existing Code
82
物件技g的新手通常不意在小任丈线\用小物件 ― 像是Y合抵岛e的
money class、含一起始值和一Y束值的range class、a或]f^（ZIP）
等等的特殊strings。你可以\用Replace Data Value with Object（175）⒃本
存在的Y料值替Q槲锛，亩走出鹘y的洞窟，M入炙手可岬奈锛世界。
如果欲替Q之Y料值是type code（型e代a），而它K不影行椋你可以\用
Replace Type Code with Class（218）⑺Q掉。如果你有相依於此type code的l
件式，可\用Replace Type Code with Subclass（213）或Replace Type Code with
State/Strategy（227）加以理。
如果你有一M是被放在一起的谖唬fields），可\用Extract Class（149）。
如果你在盗兄锌吹交本型Y料，不妨Introduce Parameter Object（295）。
如果你lF自己正array中挑xY料，可\用Replace Array with Object（186）。
3.10 Switch Statements（switch @悚F身）
物件向程式的一最明@特徵就是：少用switch（或case）述句。谋举|上
f，switch 述句的}在於重}（duplication）。你常lF同拥switch 述句
散鸯恫煌地c。如果要樗添加一新的case 子句，你必找到所有switch
述句K修改它。物件向中的多型（polymorphism）概念可榇雅的解
Qk法。
大多r候，一看到switch 述句你就考]以「多型」硖Q它。}是多型
出F在哪海switch 述句常常根type code（型e代a）M行x瘢你要的
是「ctype code相P的函式或class」。所以你使用Extract Method（110）
switch 述句提到一立函式中，再以Move Method（142）⑺搬移到需
要多型性的那class e^。此r你必Q定是否使用Replace Type Code with
Subclasses（223）或Replace Type Code with State/Strategy（227）。一旦@油
成^承Y之後，你就可以\用Replace Conditional with Polymorphism（255）了。
如果你只是在我缓式中有些x袷吕，而你K不想改铀，那N「多型」就
有c㈦u用牛刀了。@N情r下Replace Parameter with Explicit Methods（285）
是不e的x瘛Ｈ绻你的xl件之一是null，可以Introduce Null Object
（260）。
3.11 Parallel Inheritance Hierarchies（平行^承w系）
Refactoring C Improving the Design of Existing Code
83
3.11 Parallel Inheritance Hierarchies（平行^承w系）
Parallel Inheritance Hierarchies其是Shotgun Surgery的特殊情r。在@N
情r下，每你槟class 增加一subclass，必也榱硪class 相增加一
subclass。如果你lF某^承w系的class 名Q字首和另一^承w系的class
名Q字首完全相同，便是到了@N奈兜馈
消除@N重}性的一般策略是：一^承w系的w（instances）指涉（⒖肌
引用、refer to）另一^承w系的w（instances）。如果再接再\用Move Method
（142）和Move Field（146），就可以⒅干娑耍referring class）的^承w系消弭
於o形。
3.12 Lazy Class（冗Te）
你所建的每一class，都得有人去理解它、So它，@些工作都是要花X的。
如果一class的所得不值其身r，它就消失。０钢薪常出F@拥那r：
某class 原本Φ闷鹱约旱纳r，但重使它身形s水，不再做那N多工作；或
_l者事前了某些化，K添加一class 付@些化，但化H上]
有l生。不上述哪一N原因，@class f栏傲x吧。如果某些subclass ]
有做M足蚬ぷ鳎Collapse Hierarchy（344）。於缀]用的M件，你
以Inline Class（154）Ω端。
3.13 Speculative Generality（夸夸其未硇裕
@令我十分敏感的奈兜溃命名者是Brian Foote。有人f『噢，我想我
有一天需要做@事』K因而企D以各式各拥旃矗hooks）和特殊情r硖理
一些非必要的事情，@N奈兜谰统霈F了。那N做的Y果往往造成系y更y理解
和So。如果所有b置都被用到，那就值得那N做；如果用不到，就不值得。
用不上的b置只跄愕穆罚所以，把它搬_吧。
如果你的某abstract class 其]有太大作用，\用Collapse Hierarchy（344）。
非必要之delegation（委）可\用Inline Class（154）除掉。如果函式的某些
滴幢挥蒙希可λ施Remove Parameter（277）。如果函式名Qв卸囵N的
抽象意味，λ施Rename Method（273）它F一些。
如果函式或class 的惟一使用者是test cases（y案例），@就h出了奈兜
Speculative Generality。如果你lF@拥暮式或class，把它B同其test cases
第3 章 程式a的奈兜
Refactoring C Improving the Design of Existing Code
84
都h掉。但如果它的用途是椭test caseszy正功能，然必刀下留人。
3.14 Temporary Field（令人迷惑的r谖唬
有r你看到@拥奈锛：其饶instance H槟撤N特定情荻O。@
的程式a人不易理解，因槟阃ǔＵJ槲锛在所有r候都需要它的所有怠
在滴幢皇褂玫那r下猜y初其O置目的，你l。
使用Extract Class（149）o@可z的孤造一家，然後把所有和@
迪嚓P的程式a都放M@新家。也S你可以使用Introduce Null Object（260）
在「挡缓戏ā沟那r下建一Null 物件，亩避免出「l件式程式a」。
如果class 中有一}s演算法，需要好担往往就可能е奈兜
Temporary Field 的出F。由於作者不希望鬟f一L串担ㄏ胂槭颤N），
所以他把@些刀挤胚M谖唬fields）中。但是@些谖恢辉谑褂迷演算法r才
有效，其他情r下只人迷惑。@r候你可以利用Extract Class（149）把@些
岛推湎嚓P函式提到一立class中。提後的新物件⑹且method object
[Beck]（g]：其存在只是榱颂峁┖艚泻式的途剑class 本身Ko抽象意味）。
3.15 Message Chains（^度耦合的息）
如果你看到用粝蛞物件索求（request）另一物件，然後再向後者索求另一
物件，然後再索求另一物件…@就是Message Chain。H程式a中你看到
的可能是一L串getThis()或一L串r怠裥羞@N方式，意味客⑴c搜
み^程中的航行Y（structure of navigation）o密耦合。一旦物件g的PSl生
任何化，客舳司筒坏貌蛔鞒鱿修改。
@r候你使用Hide Delegate（157）。你可以在Message Chain 的不同位置
M行@N重手法。理上你可以重Message Chain 上的任何一物件，但@
N做往往把所有中介物件（intermediate object）都成Middle Man。通常更好
的x袷牵合扔^察Message Chain 最K得到的物件是用质颤N的，看看能否以
Extract Method（110）把使用物件的程式a提到一立函式中，再\用Move
Method（142）把@函式推入Message Chain。如果@l上的某物件有多位
客舸蛩愫叫写撕骄的剩N部分，就加一函式碜鲞@件事。
有些人把任何函式（method chain。g]：就是Message Chain；物件向I域
中所^「l送息」就是「酒鸷式」）都|西，我不@酉搿：呛牵
我的冷o定是出了名的，起a在@件事情上是@印
3.16 Middle Man（中gD手人）
Refactoring C Improving the Design of Existing Code
85
3.16 Middle Man（中gD手人）
物件的基本特徵之一就是封b（encapsulation）― ν獠渴澜珉[藏其炔考。
封b往往伴Sdelegation（委）。比如f你主管是否有rg⒓右h，他
就把@息委o他的事簿，然後才能回答你。很好，你]必要知道@位主
管到底使用鹘y事簿或子事簿抑或秘碛自己的s。
但是人可能^度\用delegation。你也S看到某class 介面有一半的函式都
委o其他class，@泳褪沁^度\用。@r你使用Remove Middle Man（160），
直接和物件打交道。如果@印覆事」的函式只有少，可以\用Inline
Method（117）把它 "inlining" 放M呼叫端。如果@些Middle Man 有其他行
椋你可以\用Replace Delegation with Inheritance（355）把它成物件的
subclass，@幽慵瓤梢U展原物件的行椋又不必那N多的委幼鳌
3.17 Inappropriate Intimacy（狎筷PS）
有r你看到classes ^於H密，花M太多rg去探究彼此的private 成分。如
果@l生在「人」之g，我不必做l道之士；但於classes，我希望它
朗厍逡。
就像古代偃艘樱^份狎康classes 必拆散。你可以裼Move Method（142）
和Move Field（146）退清界，亩p少狎啃健Ｄ阋部梢钥纯词欠襁\
用Change Bidirectional Association to Unidirectional（200）其中一class α
一嗲樗肌Ｈ绻classes 在是情投意合，可以\用Extract Class（149）
把烧吖餐c提到一安全地c，它坦地使用@新class。或者也可以
L\用Hide Delegate（157）另一class 樗鬟f相思情。
^承（inheritance）往往造成^度H密，因subclass superclass 的了解是超
^superclass 的主^望。如果你X得@孩子自生活了，\用Replace
Inheritance with Delegation（352）它x_^承w系。
3.18 Alternative Classes with Different Interfaces
（曲同工的e）
如果函式做同一件事，s有著不同的署名式（signature），\用Rename Method
第3 章 程式a的奈兜
Refactoring C Improving the Design of Existing Code
86
（273）根它的用途重新命名。但@往往不颍反瓦\用Move Method（142）
⒛承┬橐迫classes，直到烧叩f定（protocols）一致橹埂Ｈ绻你必重}
而N地移入程式a才能完成@些，或S可\用Extract Superclass（336）樽约
Hc罪。
3.19 Incomplete Library Class（不完美的程式祛e）
陀茫reuse）常被槲锛的KO目的。我J檫@在是^度估了（我只
是使用而已）。但是o可否J，S多程技g都建立在library classes（程式祛
e）的基A上，]人敢f是不是我都把排序演算法忘得一乾二Q了。
library classes B者]有未卜先知的能力，我不能因此怪他。竟我自
己也缀蹩是在系y快要B完成的r候才能弄清楚它的O，所以library B
者的任照娴暮芷D。麻┑氖library 的形式（form）往往不蚝茫往往不可能
我修改其中的classes 使它完成我希望完成的工作。@是否意味那些^
`z的鹦g如Move Method（142）等等，如今都派不上用隽耍
幸好我有ｉT付@N情r的工具。如果你只想修改library classes 鹊囊
函式，可以\用Introduce Foreign Method（162）；如果想要添加一大堆~外
行椋就得\用Introduce Local Extension（164）。
3.20 Data Class（稚的Y料e）
所^Data Class是指：它碛幸恍谖唬fields），以及用於存取（x）@些
谖坏暮式，除此之外一oL物。@拥classes 只是一N「不f的Y料容器」，
它缀跻欢ū黄渌classes ^份地操控著。@些classes 早期可能碛public
谖唬果真如此你在e人注意到它之前，立刻\用Encapsulate Field（206）
⑺封b起怼Ｈ绻@些classes 群容器的谖唬collection fields），你
z查它是不是得到了恰的封b；如果]有，就\用Encapsulate Collection（208）
把它封b起怼於那些不被其他classes 修改的谖唬\用Remove Setting
Method（300）。
然後，找出@些「取值/O值」函式（getting and setting methods）被其他classes \
用的地c。L以Move Method（142）把那些呼叫行榘嵋频Data Class怼Ｈ
果o法搬移整函式，就\用Extract Method（110）a生一可被搬移的函式。
不久之後你就可以\用Hide Method（303）把@些「取值/O值」函式[藏起砹恕
3.21 Refused Bequest（被拒^的z）
Refactoring C Improving the Design of Existing Code
87
Data Class 就像小孩子。作橐起c很好，但若要它像「成年（成熟）」
的物件那⑴c整系y的工作，它就必承一定任。
3.21 Refused Bequest（被拒^的z）
subclasses ^承superclass 的函式和Y料。但如果它不想或不需要^承，又
怎Nk呢？它得到所有Y物，s只闹刑暨x硗妫
按鹘yf法，@就意味^承w系Oe`。你需要檫@subclass 新建一兄弟
（sibling class），再\用Push Down Method（328）和Push Down Field（329）把
所有用不到的函式下推o那兄弟。@右superclass 就只持有所有subclasses 共
享的|西。常常你到@拥慕ㄗh：所有superclasses 都是抽象的（abstract）。
既然使用「鹘yf法」@略зHx的~，你就可以猜到，我不建h你@N做，
起a不建h你每次都@N做。我常利用subclassing 手法陀靡恍┬椋K
lF@可以很好地用於日常工作。@也是一N奈兜溃我不否J，但馕锻
常K不烈。所以我f：如果Refused Bequest 引起困惑和}，遵循鹘y
忠告。但不必J槟忝看味嫉媚屈N做。十有八九@N奈兜篮艿，不值得理睬。
如果subclass 陀昧superclass 的行椋作），s又不意支援superclass 的介
面，Refused Bequest 的奈兜谰得饬摇＞芙^^承superclass 的作，@一
c我不介意；但如果拒^^承superclass 的介面，我不以槿弧２贿^即使你不
意^承介面，也不要胡y修改^承w系，你\用Replace Inheritance with
Delegation（352）磉_到目的。
3.22 Comments（^多的]）
e心，我K不是f你不]。男嵊X上f，Comments不是一N奈兜溃
事上它是一N香味呢。我之所以要在@e提到Comments，因槿常
把它作除臭硎褂谩３３有@拥那r：你看到一段程式a有著LL的]
，然後lF，@些]之所以存在乃是因槌淌酱a很糟糕。@N情r的l生次
抵多，在令人吃@。
Comments 可以我找到本章先前提到的各N奈兜馈Ｕ业奈兜泪幔我首
先以各N重手法把奈兜廊コ。完成之後我常常lF：]已得
多N了，因槌淌酱a已清楚f明了一切。
第3 章 程式a的奈兜
Refactoring C Improving the Design of Existing Code
88
如果你需要]斫忉一K程式a做了什N，Extract Method（110）；如果
method已提出恚但是需要]斫忉其行椋Rename Method（273）；
如果你需要]f明某些系y的需求格，Introduce Assertion（267）。
你感X需要撰]，先L重，著所有]都得多N。
如果你不知道做什N，@才是]的良好\用rC。除了用碛述淼拇蛩
之外，]可以用擞你Ko十足把握的^域。你可以在]e下自己「
什N做某某事」。@Y可以椭淼男薷恼撸尤其是那些健忘的砘铩
第3 章 程式a的奈兜
4.1 自我ya（Self-testing Code）的r值
Refactoring C Improving the Design of Existing Code
89
第4 章 建立yw系4
Byw系
Building Test
如果你想M行重（refactoring），首要前提就是碛幸可靠的yh境。就算
你蛐疫\，有一可以自舆M行重的工具，你是需要y。而且短rg炔
可能有任何工具可以槲自舆M行所有可能的重。
我K不把@槿秉c。我lF，良的y程式，可以O大提高我的程速
度，即使不M行重也一尤绱恕＿@我很吃@，也`反S多程式T的直X，所
以我有必要解一下@F象。
4.1 自我ya（Self-testing Code）的r值
如果J真^察程式T把最多rg耗在哪e，你就lF，程式其只追浅
小的一部分。有些rg用Q定下一步质颤N，另一些rg花在O上面，最多
的rgt是用沓e（debug）。我敢肯定每一位x者都得自己花在除e上面
的o小r，o荡瓮ㄏ_旦。每程式T都能v出「花一整天（甚至更多）
rg只找出一b小小臭x」的故事。修湾e`通常是比^快的，但找出e`s是
噩粢觥．你修好一e`，是有另一e`出F，而且肯定要很久以後
才注意到它。彼r你又要花上大把rg去ふ宜。
我走上「自我ya」@l路，肇因於1992 年OOPSLA 大上的一次演v。
錾嫌腥耍ㄎ矣得好像是Dave Thomas）f：『class 包含它自己的ya。』
@激l了我的`感，我想到一NMy的好方法。我@咏忉它：每class
都有一y函式，K以它y自己@class。
那r候我著迷於增量式_l（incremental development），所以我L在Y束每
次增量r，槊class 添加y。r我_l的案子很小，所以我大s每L增
量一次。绦y得相直率，但管如此，做@些y是很┤耍因槊
第4 章 建立yw系
Refactoring C Improving the Design of Existing Code
90
y都把Y果出到主控台（console），而我必逐一z查它。我是很
的人，我情下努力工作以免除日後的工作。我意R到我其完全不必自己盯
著幕zy所得Y是否正_，我大可X臀易鲞@件事。我需要做的
就是把我所期望的出放Mya中，然後做一比^就行了。於是我可以舒服
地绦忻class 的y函式，如果一切都]}，幕上就只出F一 "OK"。
F在，@些classes都成「自我y」了。
_保所有y都完全自踊，它z查自己的yY果。
此後再M行y就味嗔耍和g一雍巍ｌ妒俏议_始在每次g之後都M
行y。很快我lF自己的生a效率大大提高。我意R到那是因槲]有花太多
rg去除e。如果我不小心引入一可被原y捕捉到的e`，那N只要我绦
y，它就向我蟾孢@e`。由於y本硎强梢哉常绦械模所以我知道
@e`必定是在前一次绦y後引入。由於我l繁地M行y，每次y都
在不久之前，因此我知道e`的源^就是我下的程式a。而由於我δ嵌
程式aq新，份量也很小，所以p就能找到e`。那靶枰一小r甚至更
多rg才能找到的e`，F在最多只需煞昼就找到了。之所以能碛腥绱
大的慑e能力，不HH因槲B了self-testing classes（自我ye），也因
我l繁地绦兴。
注意到@一c後，我y的eO性更高了。我不再等待每次增量Y束，只要
好一c功能，我就立即添加y。每天我都添加一些新功能，同r也添加相
的y。那些日子e，我很少花一分以上的rg在除e上面。
一整M（a suite of）y就是一大的臭xy器，能虼蟠罂sp搜こ粝x所需
要的rg。
然，f服e人也@N做，K不容易。y程式，意味要很多~外程式a。
除非你_切w到@N方法程速度的提N，否t自我y就@不出它的意x。
很多人根本]W^如何y程式，甚至根本]考]^y，@於自我
ya也很不利。如果需要手绦y，那更是令人欲I；但如果可以自
绦校ya就真的很有趣。
4.2 JUnit y框架 （Testing Framework）
Refactoring C Improving the Design of Existing Code
91
H上，撰ya的最有用rC是在_始程之前。你需要添加特性的r候，
先相ya。起黼x叛道，其不然。ya其就是在自己：
添加@功能需要做些什N。ya能使你把注意力集中於介面而非作
上^（@永h是件好事）。A先好的ya也槟愕墓ぷ靼采弦明_的Y束
苏I：一旦ya正常绦校工作就可以Y束了。
「l繁M行y」是O限程（eXtreme Programming，XP） [Beck, XP] 的重要
一h。「O限程」一~容易人想起那些aw快、自由而散漫的客
（hackers），H上O限程者都是十分Ｗ⒌y者。他希望可能快速_
lw，而他也知道「y」可f助他可能快速地前M。
至此可休矣。管我相信每人都可以木自我ya中受益，但@K不
是本重c。本的是重，而重需要y。如果你想重，你就必
ya。本章⒔棠恪敢Java ya」的起步知R。@不是一本Ｖvy的
，所以我不想v得太仔。但我lF，少量y就足以眢@人的利益。
和本其他热菀樱我以例斫榻By手法。_lw的r候，我一撰
程式a，一撰ya。但是我和他人K肩重r，往往得面υS多o自我
y的程式a。所以重之前我首先必把@些程式a改造椤缸晕y」。
Java之中的yT用手法是 "testing main"，意思是每class 都有一用於y
的main()。@是一合理的T（管K不那N值得QS），但可能不好操控。
@N作法的}是很yp绦卸y。另一N作法是：建立一立class 用
於y，K在一框架（framework）中绦兴，使y工作更p。
4.2 JUnit y框架（Testing Framework）
g]：本段⑹褂糜⑽脑~：test-suite（y套件）、test-case（y案例）和test-fixture
（yb洌，期能直接D4.1的JUnit YM件，K有助於xJUnit 文件。
我用的是JUnit，一由Erich Gamma 和Kent Beck [JUnit] _l的源a_放y框
架。@框架非常危s可你M行y所需的所有重要事情。本章中我⑦\
用@y框架橐恍IO classes _lya。
首先我建一FileReaderTester class yn案x取器。任何「包含ya」
的class都必衍生自y框架所提供的TestCase class。@框架\用Composite
第4 章 建立yw系
Refactoring C Improving the Design of Existing Code
92
式 [Gang of Four]，允S你ya聚集到suites（套件）中，如D4.1。@些套
件可以包含未加工的test-cases（y案例），或其他test-suits（y套件）。如
此一砦揖涂梢暂p地⒁幌盗旋大的test-suits Y合在一起，K自绦兴。
TestSuite
（y套件）
*
TestCase
（y案例）
Test
FileReaderTester
junit.framework
.interface.
D4.1 y框架的CompositeY
class FileReaderTester extends TestCase {
public FileReaderTester (String name) {
super(name);
}
}
@新建的class 必有一建式。完成之後我就可以_始添加ya了。我的
第一件工作是O置test fixture（yb洌，那是指「用於y的物件颖尽埂Ｓ
於我要x一n案，所以先渫滓yn如下：
Bradman 99.94 52 80 10 6996 334 29
Pollock 60.97 23 41 4 2256 274 7
Headley 60.83 22 40 4 2190 270* 10
Sutcliffe 60.73 54 84 9 4555 194 16
M一步\用@n案之前，我得先浜test fixture（yb洌。TestCase class
提供函式ｉTΥ艘挥猛荆setUp()用懋a生相P物件、tearDown()
h除它。在TestCase class 中@函式都只有空ぁ４蠖r候你不需要操
心test fixture 的拆除（垃圾回收器扛起任），但是在@e，以tearDown() P
]n案o疑是明智之e：
4.2 JUnit y框架 （Testing Framework）
Refactoring C Improving the Design of Existing Code
93
class FileReaderTester...
protected void setUp() {
try {
_input = new FileReader("data.txt");
} catch (FileNotFoundException e) {
throw new RuntimeException ("unable to open test file");
}
}
protected void tearDown() {
try {
_input.close();
} catch (IOException e) {
throw new RuntimeException ("error on closing test file");
}
}
F在我有了m的test fixture（yb洌，可以_始ya了。首先要y
的是read()，我要x取一些字元，然後z查後mx取的字元是否正_：
public void testRead() throws IOException {
char ch = '&';
for (int i=0; i < 4; i++)
ch = (char) _input.read();
assert('d' == ch);
}
assert()扮演自y角色。如果assert()的抵true，一切良好；否t我
就收到e`通知。稍後我你看看y框架怎N向使用者蟾驽e`息。
F在我要先介B如何y^程绦衅怼
第一步是a生一test suite（y套件）。檫_目的，O一suite()如下：
class FileReaderTester...
public static Test suite() {
TestSuite suite= new TestSuite();
suite.addTest(new FileReaderTester("testRead"));
return suite;
}
@y套件只含一test-case（y案例）物件，那是FileReaderTester
w。建test-case 物件r，我鹘o其建式一字串，@正是待y函式的名Q。
@建出一物件，用以y被指定的函式。@yS透^Java 反射C制
（reflection）和物件MY在一起。你可以自由下dJUnit 源a，看看它究竟如何做
到。至於我，我只把它作一N魔法。
第4 章 建立yw系
Refactoring C Improving the Design of Existing Code
94
要⒄y绦衅恚需要一立的TestRunner class。TestRunner 有
版本，其中一有漂亮的D形使用介面（GUI），另一裼梦淖纸槊妗Ｎ铱梢
在main函式中叫用「文字介面」版：
class FileReaderTester...
public static void main (String[] args) {
junit.textui.TestRunner.run (suite());
}
@段程式a建出一TestRunner，K要它去yFileReaderTester class。
我绦兴，我看到：
.
Time: 0.110
OK (1 tests)
於每绦衅淼y，JUnit 都出一句c，@幽憔涂梢灾庇^看到y
M展。它告V你整y用了多Lrg。如果所有y都]有出e，它就f
"OK"，K告V你绦辛硕嗌俟Py。我可以绦猩锨ЧPy，如果一切良好，我
看到那 "OK"。於自我ya碚f，@蔚幕至P重要，]有它我就
不可能常绦羞@些y。有了@位，你可以绦幸淮蠖y然後去吃
午（或_），回碇後再看看yY果。
l繁地绦y。每次g把y也考]M去 ― 每天至少绦忻y一次。
重^程中，你可以只绦猩醉y，它主要用z查下正在_l或整
理的程式a。是的，你可以只绦猩醉y，@涌隙ū容^快，否t整y
p低你的_l速度，使你_始q豫是否要@酉氯ァＧfe屈服於@NT
惑，否t你一定付出代r。
如果y出e，l生什N事？榱苏故具@N情r，我故意放一b臭xM去：
public void testRead() throws IOException {
char ch = '&';
for (int i=0; i < 4; i++)
ch = (char) _input.read();
assert('2' == ch); // deliberate error
}
得到如下Y果：
.F
Time: 0.220
!!!FAILURES!!!
4.2 JUnit y框架 （Testing Framework）
Refactoring C Improving the Design of Existing Code
95
Test Results:
Run: 1 Failures: 1 Errors: 0
There was 1 failure:
1) FileReaderTester.testRead
test.framework.AssertionFailedError
JUnit 警告我y失。K告V我@失【唧wl生在哪y身上。不^@e
`息K不特e有用。我可以使用另一N形式的assert，e`息更清楚些：
public void testRead() throws IOException {
char ch = '&';
for (int i=0; i < 4; i++)
ch = (char) _input.read();
assertEquals('m',ch);
}
你做的^大多asserts 都是值M行比^，z它是否相等，所以JUnit
框架槟闾峁assertEquals()。@函式很危阂equals()M行物件比^，
以\算子 == M行抵当容^ ― 我自己常忘^分它。@函式也出更具意
x的e`息：
.F
Time: 0.170
!!!FAILURES!!!
Test Results:
Run: 1 Failures: 1 Errors: 0
There was 1 failure:
1) FileReaderTester.testRead "expected:"m"but was:"d""
我提一下：yar，我往往一_始先它失　Ｃ既有程式a，
要不我就修改它（如果我能碰|源a的），使它y失。要不就在assertions
中放一e`期望值，造成y失　Ｖ所以@N做，是榱讼蜃约鹤C明：y
C制的_可以绦校K且的_y了它y的|西（@就是槭颤N上面煞N作
法中我比^喜g修改待ya的原因）。@可能有些偏蹋或S吧，但如果ya
所y的|西K非你想y的|西，你真的有可能被搞得迷迷糊糊。
除了捕捉「失　梗failures，也就是assertions 之Y果 "false"），JUnit 可以
捕捉「e`」（errors，意料外的常）。如果我P]input stream，然後Dx取
它，就得到一常（exception）。我可以@y：
public void testRead() throws IOException {
char ch = '&';
_input.close();
for (int i=0; i < 4; i++)
ch = (char) _input.read(); // will throw exception
assertEquals('m',ch);
}
第4 章 建立yw系
Refactoring C Improving the Design of Existing Code
96
绦猩鲜y，我得到@拥慕Y果：
.E
Time: 0.110
!!!FAILURES!!!
Test Results:
Run: 1 Failures: 0 Errors: 1
There was 1 error:
1) FileReaderTester.testRead
java.io.IOException: Stream closed
^分失。failures）和e`（errors）是很有用的，因樗的出F形式不同，排
除的^程也不同。
JUnit 包含一很好的D形使用介面（GUI，D4.2）。如果所有y都利通
^，窗下端的M度U（progress bar）就呈G色；如果有任何一y失。M
度U就呈t色。你可以G下@GUI 不管，整h境自⒛阍诔淌酱a所做的
任何修改B接（links）M怼＿@是一非常方便的yh境。
D4.2 JUnit的D形使用界面
卧y（Unit Tests）和功能y（Functional Tests）
JUnit 框架的用途是卧y，所以我vv卧y和功能y之g的差。
我一直煸谧焐系钠是「卧y」，@些y的目的是榱颂岣呱橐
程式T的生a效率。至於品管部T_心，那只是附效果而已。卧y
4.3 添加更多y
Refactoring C Improving the Design of Existing Code
97
是高度^域化（localized）的|西，每test class 只我package \作。它能
y其他packages 的介面，除此之外它⒓僭O其他package 一切正常。
功能y就完全不同。它用肀ＷCw能蛘常\作。它只向客籼峁
品|保C，K不P心程式T的生a力。它由一喜gふ页粝x的eF
黹_l。@F使用重量工具和技g椭自己_l良好的功能y。
一般而言，功能y可能把整系y作一黑箱。面σGUI 待y系y，
它透^GUI 聿僮髂系y。面n案更新程式或Y料旄新程式，功能y
只^察特定入所е碌馁Y料化。
一旦功能y者或K端用粽业杰w中的一b臭x，要除掉它至少需要做杉事。
然你必修改程式a，才得以排除e`，但你添加一卧y，它
揭l@b臭x。事上，每收到臭x提螅bug report），我都首先一
元y，使@b臭x浮F。如果需要s小臭x出]，或如果出F其他相P失
。failures），我就不只一y。我使用卧y椭我盯住臭x，
K_保我的卧y不有似的漏W之…呃…臭x。
每你接@臭x提螅bug report），先撰一卧y斫野l@b臭x。
JUnit 框架被O用砭卧y。功能y往往以其他工具o助M行，例如某
些碛GUI（D形使用介面）的y工具，然而通常你得撰一些c你的用
程式息息相P的y工具，俾能虮渭使用GUI scripts（_本Z言）更p地
管理test cases（y案例）。你也可以\用JUnit 绦泄δy，但@通常不是
最有效的形式。我要M行重r，我倚程式T的好朋友：卧y。
4.3 添加更多y
F在，我^m添加更多y。我遵循的L格是：^察class 做的所有事情，
然後θ魏我豁功能的任何一N可能失∏r，M行y。@不同於某些程式
T提倡的「y所有public 函式」。住，y是一NLU樱risk driven）
行椋y的目的是希望找出F在或未砜赡艹霈F的e`。所以我不去y那
些HHx或一谖坏拇嫒『式（accessors），因樗太瘟耍不大可能出
e。
第4 章 建立yw系
Refactoring C Improving the Design of Existing Code
98
@一c很重要，因槿绻你撰^多y，Y果往往y量反而不颉Ｎ页３ｉ
xS多y相P籍，我的反是：y需要做那N多工作，令我退避三舍。@
N起不了A期效果，因樗你X得y有大量工作要做。事上，哪怕只做
一ccy，你也能闹惺芤妗y的要E是：y你最心出e的部分。@
你就能y工作中得到最大利益。
未臻完善的yKH绦校好^ν昝y的oM等待。
F在，我的目光落到了read()。它做些什N？文件上f，input stream
到_n案尾端，read()骰 -1（在我看磉@K不是很好的f定，不^我猜
@C 程式T倍感H切）。我y一下。我的文字器告V我，我的
yn共有141字元，於是我撰ya如下：
public void testReadAtEnd() throws IOException {
int ch = -1234;
for (int i = 0; i < 141; i++)
ch = _input.read();
assertEquals("read at end", -1, _input.read());
}
榱俗@y绦衅恚我必把它添加到test suit（y套件）中：
public static Test suite() { // g]：原本在p.93
TestSuite suite= new TestSuite();
suite.addTest(new FileReaderTester("testRead"));
suite.addTest(new FileReaderTester("testReadAtEnd"));
return suite;
}
test suit（y套件）绦衅恚它告V我它的每成分 ― 也就是@test
cases（y案例）― 的绦星r。每案例都呼叫setUp()，然後绦ya，
最K呼叫tearDown()。每次y都呼叫setUp()和tearDown()是很重要的，因
檫@硬拍鼙ＷCy之g彼此隔x。也就是f我可以按任意序绦兴，不
λ的Y果造成任何影。
老要住test cases添加到suite()，在是件痛苦的事。幸\的是Erich Gamma
和Kent Beck和我一校所以他提供了一l途肀苊膺@N痛苦。TestSuite
class 有特殊建式，接受一class 担建出淼test suite⒃class
4.3 添加更多y
Refactoring C Improving the Design of Existing Code
99
人有以 "test" 起^的函式都作test cases 包含M怼Ｈ绻遵循@一命名T，
就可以把我的main()改檫@樱
public static void main (String[] args) { // g]：原出F於p94
junit.textui.TestRunner.run (new TestSuite(FileReaderTester.class));
}
@樱我的每一y函式便都被自犹砑拥test suite中。
y的一重要技巧就是「ふ疫界l件」。read()而言，界l件是第
一字元、最後一字元、倒档诙字元：
public void testReadBoundaries()throwsIOException {
assertEquals("read first char",'B', _input.read());
int ch;
for (int i = 1; i <140; i++)
ch = _input.read();
assertEquals("read last char",'6',_input.read());
assertEquals("read at end",-1,_input.read());
}
你可以在assertions中加入一l息。如果y失。@l息就被@示出怼
考]可能出e的界l件，把y火力集中在那骸
「ふ疫界l件」也包括ふ姨厥獾摹⒖赡еy失〉那r。於n案相P
y，空n案是不e的界l件：
public void testEmptyRead()throws IOException {
File empty = new File ("empty.txt");
FileOutputStream out = new FileOutputStream (empty);
out.close();
FileReader in = new FileReader (empty);
assertEquals (-1, in.read());
}
F在我檫@ya生一些~外的test fixture（yb洌。如果以後需要空n
案，我可以把@些程式a移至setUp()，亩「空n案」加入常test fixture。
protected void setUp(){
try {
_input = new FileReader("data.txt");
_empty = newEmptyFile();
} catch(IOException e){
throw new RuntimeException(e.toString());
}
}
第4 章 建立yw系
Refactoring C Improving the Design of Existing Code
100
private FileReader newEmptyFile() throws IOException {
File empty = new File ("empty.txt");
FileOutputStream out = new FileOutputStream(empty);
out.close();
return newFileReader(empty);
}
public void testEmptyRead() throws IOException {
assertEquals (-1, _empty.read());
}
如果x取n案末尾之後的位置，l生什N事？同返回-1。F在我再加一
y硖y@一c：
public void testReadBoundaries() throws IOException {
assertEquals("read first char",'B', _input.read());
int ch;
for (int i = 1;i <140; i++)
ch = _input.read();
assertEquals("read last char", '6', _input.read());
assertEquals("read at end",-1,_input.read());
assertEquals ("readpast end", -1, _input.read());
}
注意，我在@e扮演「程式公场沟慕巧。我eO思考如何破某淌酱a。我lF
@N思S能蛱岣呱a力，K且很有趣。它v容了我心智中比^促M的那一部分。
yr，e忘了z查A期的e`是否如期出F。如果你L在stream 被P]後再
x取它，就得到一IOException常，@也被y出恚
public void testReadAfterClose() throws IOException{
_input.close();
try {
_input.read();
fail ("no exception for read past end");
} catch (IOException io) {}
}
IOException之外的任何常都⒁砸话惴绞叫纬梢e`。
事情被大家J出er，e忘了z查彼r是否有常如A期般地被出。
4.3 添加更多y
Refactoring C Improving the Design of Existing Code
101
遵循@些t，不嘭S富你的y。於某些比^}s的classes，可能你得花
M一些rgg[其介面，但是在此^程中你可以真正理解@介面。而且@
於考]e`情r和界情r特e有椭。@是在程式a的同r（甚至之前）
ya的另一好。
S著tester classes愈碛多，你可以a生另一class，ｉT用戆含「由其他tester
classes 所形成」的y套件（test suite）。@很容易做到，因橐y套件本
就可以包含其他y套件。@樱你就可以碛幸「主控的」（master）test class：
class MasterTester extends TestCase {
public static void main (String[] args) {
junit.textui.TestRunner.run (suite());
}
public static Test suite() {
TestSuite result = new TestSuite();
result.addTest(new TestSuite(FileReaderTester.class));
result.addTest(new TestSuite(FileWriterTester.class));
// and so on...
return result;
}
}
什Nr候停下恚课蚁嘈胚@拥脑你^很多次：「任何y都不能C明一
程式]有臭x」。@是真的，但@不影「y可以提高程速度」。我曾
^捣Nyt建h，其目的都是保C你能y所有情r的一切M合。@
些|西值得一看，但是e它影你。y盗窟_到一定程度之後，y效
益就呈FfpB荩而非持mf增；如果D太多y，你也可能因楣
作量太大而怵H，最後什N都不成。你把y集中在可能出e的地方。^
察程式a，看哪鹤得}s；^察函式，思考哪些地方可能出e。是的，你的y
不可能找出所有臭x，但一旦M行重，你可以更好地理解整程式，亩找
到更多臭x。m然我是以为一y套件（test suite）_始重，但前M途中
我加入更多y。
不要因椤yo法捕捉所有臭x」，就不撰ya，因y的_可以捕捉
到大多党粝x。
物件技g有微妙：^承（inheritance）和多型（polymorphism）y得
比^困y，因⒂性S多NM合需要y。如果你有三彼此合作的abstract
classes，每abstract class 有三subclasses，那N你共碛芯可供x竦
第4 章 建立yw系
Refactoring C Improving the Design of Existing Code
102
classes，和27 NM合。我K不是著y所有可能M合，但我量y每一
classes，@可以大大p少各NM合所造成的LU。如果@些classes 之g彼此有
合理的立性，我很可能不L所有M合。是的，我有可能z漏些什N，但
我X得「花合理rg抓出大多党粝x」要好^「FM一生抓出所有臭x」。
ya和a品a（待ya）之g有^e：你可以放心地拷、ya。
理多NM合情r以及面Χ可供x竦classes r，我常@N做。首先y「
拾l薪^程」，然後加上「Yv」和「年底前停薪」l件，然後又去掉@l
件…等等等。只要在合理的yb洌test fixture）上浜靡恍┖蔚奶Q颖荆
我就能蚝芸焐成不同的test case（y案例），然後就可以利用重手法分解出
真正常用的各N|西。
我希望@一章能蜃你於「撰ya」有一些感X。P於@主}，我可以
f上很多，但如果那N做，就有c喧eZ主了。而言之，B一良好的臭
xzy器（bug detector）K常绦兴；@θ魏伍_l工作都是一美好的工具，
K且是重的前提。
第4 章 建立yw系
5.1 重的格式 （Format of Refactorings）
Refactoring C Improving the Design of Existing Code
103
第5 章 重名5
重名
Toward a Catalog of Refactorings
本5~12章成了一份重名草案（initial catalog of refactorings）。其中所列
的重手法碜晕易罱的甑男牡谩＿@份名K非靡z，但足可槟闾
供一的起c，你得以_始自己的重工作。
5.1 重的格式（Format of Refactorings）
介B重r，我裼靡环N矢袷健Ｃ重手法都有如下五部分：
! 首先是名Q（name）。建造一重~”恚名Q是很重要的。@名Q也
就是我⒃诒其他地方使用的名Q。
! 名Q之後是一短概要（summary），谓榻B此一重手法的m用情景，
以及它所做的事情。@部分可以椭你更快找到你所需要的重手法。
! C（motivation），槟憬榻B「槭颤N需要@重」和「什N情r下不
使用@重」。
! 作法（mechanics），明扼要地一步一步介B如何M行此一重。
! 例（examples），以一十分蔚睦子f明此重手法如何\作。
「概要」（summary）包括三部分：(1) 一短文句，介B@重能椭
的}；(2) 一段短述，介B你做的事；(3) 一幅速D，握宫F重
前後示例；有r候我展示程式a，有r候我展示y一建模Z言（UML）D。哪一
N形式能更好呈F重的本|，我就使用N形式（本所有UML D都根
作^c（implementation perspective）而 [Fowler, UML]。）如果你以前^@
一重手法，那N速D能蜃你迅速了解@一重的概r；如果你不曾^@
重，可能就需要g[整例，才能得到^好的JR。
第5 章 重名
Refactoring C Improving the Design of Existing Code
104
「作法」（mechanics）出自我自己的P。@些P是榱俗我在一段rg不做
某重之後能得怎N做。它也H楹，通常不解「槭颤N要@N
做那N做」。我在「例」（examples）o出更多解。@N一怼缸鞣ā咕
成了短的P。如果你知道使用哪重，但不清具w步E，可以⒖肌缸
法」部分（至少我是@N使用它的）；如果你初次使用某重，可能「作法」
δ氵不颍你需要x「例」。
撰「作法」的r候，我量⒅的每步E都得短。我{安全的重
方式，所以裼梅浅Ｐ〉牟襟E，K且在每步E之後M行y。真正工作r
我通常裼帽冗@e介B的「W步」稍大些的步E，然而一旦遇上臭x，我
就撤N上一步，Q用比^小的步E。@些步E包含一些特定r的⒖迹所
以它也有z表（checklist）的作用；我自己常忘掉@些做的事情。
「例」（examples）像是味有趣的教科。我使用@些例是榱椭解
重的基本要素，最大限度地避免其他枝，所以我希望你能原其中的化
工作（它然不是秀商用物件O的m例子）。不^我敢肯定你一定能在
你手上那些更}s的情r中使用它。某些十分蔚闹乾脆]有例，因
我X得樗加上一例不有多大意x。
更明_地f，加上「例」HH是榱岁Ur的重手法。通常那些程式
a最K仍有其他}，但修正那些}需要用到其他重手法。某些情r下
重常被一氵\用，@r候我把某例拿到另一重中^m使用。大部
分r候，一例只橐豁重而O，@N做是榱俗每一重手法自o自
足（self-contained），因檫@份重名的首要目的是作⒖脊ぞ摺
@些例子不告V你「如何O一 "employee" 物件或一 "order" 物件」。@
些例子的存在粹只是榱苏f明重，除此之外eo用途。例如你lF，我在
@些例子中用double 肀硎矩沤痤~。我之所以@幼觯只是榱俗例子
我恍，因椤敢允颤N形式表示金~」於重本身K不重要。在真正的商用
w中，我烈建h你不要以double 表F金~。如果真要表示沤痤~，我使用
Quantity式 [Fowler, AP]。
5.2 ふ乙用 c（Finding References）
Refactoring C Improving the Design of Existing Code
105
撰本之H，商I_l中使用得最多的是Java 1.1，所以我的大多道子也以Java
1.1 就，@奈θ杭（collections）的使用就可以明@看出怼１即⑼瓿
之r，Java 2 已正式l选５我不X得有必要修改所有@些例子，因χ
f，群集（collections）也是次要的。但是有些重手法，例如Encapsulate Collection
（208），在Java 1.2中有所不同。@r候我同r解Java 2 和Java 1.1。
修改後的程式a可能被埋]在未修改的程式a中，y以一眼看出，所以我使用粗
w（blodface code）突@修改^的程式a。但我K]有λ有修改^的程式a
都使用粗w字，因橐坏┬薷倪^的程式a太多，全都粗w反而不能突@重c。
5.2 ふ乙用c（Finding References）
很多重都要求你找到於某函式（methods）、某谖唬fields）或某class
的所有引用c（指涉c）。做@件事的r候，得で笥算C的椭。有了算
C的椭，你可以p少「z漏某引用c」的C率，而且通常比人工搜じ快。
大多嫡Z言都把算C程式a做文字n硖理，所以最好的褪志褪且m
的文字搜すぞ摺ＴS多程h境都允S你在一n案或者一Mn案中M行文字搜
ぃ你的搜つ说拇嫒】刂疲access control）告V你需要搜さn案。
不要盲目地「搜.替Q」。你z查每一引用c，_定它的_指向你想要替
Q的|西。或S你很擅L\用搜な址ǎ但我是用心去z查，以_保替Qr不
出e。要知道，你可以在不同的classes 中使用相同函式名Q，也可以在同一class
中使用名Q相同但署名（signature）不同的函式，所以「替Q」出eC是很高的。
在型（strongly typed）Z言中，你可以g器椭你捕捉漏W之~。你往往可
以直接h除f部分，g器湍阏页鲆虼硕被吊炱恚dangling）的引用c。
@幼龅暮锰是：g器找到所有被吊斓囊用c。但是@N技巧也存在}。
首先，如果被h除的部分在^承w系（hierarchy）中宣告不止一次，那Ng器也
被迷惑。尤其你理一被覆（overridden）多次的函式r，情r更是如此。
所以如果你在一^承w系中工作，先利用文字搜すぞ撸z查是否有其他class
宣告了你正在理的那函式。
第二}是：g器可能太慢，亩使你的工作失去效率。如果真是@樱
先使用文字搜すぞ撸最起ag器可以筒槟愕墓ぷ鳌Ｖ挥挟你想移除某部
第5 章 重名
Refactoring C Improving the Design of Existing Code
106
分r，才你@幼觥３３Ｄ想先^察@一部分的所有\用情r，然後才Q定
下一步。@N情r下你必使用文字搜しǎǘ不是倚g器）。
第三}是：g器o法找到由反射C制（reflection）而得到的引用c。@
也是我小心使用反射的原因之一。如果系y中使用了反射，你就必以文
字搜ふ页瞿阆胝业|西，y份量也因此加重。有些r候我建h你只g，
不y，因榫g器通常捕捉到可能的e`。如果使用反射（reflection），所
有@些便利都]有了，你必樵S多g搭配y。
某些Java _lh境（特e值得一提的是IBM 的VisualAge）承受了Smalltalk g[
器的影。在@些_lh境中你使用功能表x（menu options）硭ひ用
c，而不是使用文字搜すぞ摺Ｒ檫@些_lh境K不以文字n保存程式a，而
是使用一冉ㄙY料臁Ｖ灰T了@些功能表x，你lF它往往比y用
的文字搜すぞ叱錾得多。
5.3 @些重t有多成熟？
任何技g作家都面@右}：在何rl表自己的想法？l表愈早，人
愈快能蜻\用新想法、新^念。但只要是人，是不嘣W。如果^早l表
半生不熟的想法，@些思想可能K不完善，甚至可能o那些L裼盟的人
砺。
重的基本技巧 ― 小步前M、l繁y ― 已得到多年的`z，特e是
在Smalltalk社群中。所以，我敢保C，重的@些基A思想是非常可靠的。
本中的重t是我自己使用重的。是的，我全都用^它。但是「使
用某重手法」和「⑺饪s成可在@eo出之作法步E」是有^e的。特e
是在一些十分特殊的情r下，偶你看一些}突然ガF。我K]有很多
人M行我所下的@些技g步E以DlF@一}。所以，使用重的r候，
Sr知道自己在做什N。住，就像看著食V做菜一樱你必@些重
tm你自己的情r。如果你遇上一有趣的}，以子]件告V我，我
著把你的情r告V其他人。
P於@些重手法，另一需要住的就是：我是在「涡谐獭梗single-process）
w@一大前提下考]K介B它的。我很希望看到有人介B用於K行式
（concurrent）和分散式（distributed）程式O的重技g。@拥闹⑹峭耆
5.3 @些重t有多成熟？
Refactoring C Improving the Design of Existing Code
107
不同的。e例子，在涡谐誊w中，你永h不必操心多Nl繁地呼叫某函式，
因楹式的呼叫成本很低。但在分散式w中，函式的往返必被p至最低限度。
在@些特殊程I域中有著完全不同的重技g，@已超越本主}。
S多重手法，例如Replace Type Code with State/Strategy（227）和Form Template
Method（345），都涉及「向系y引入式（patterns）」。正如 GoF（Gang of Four，
四巨^）的典著作中所f，『O式…槟愕闹行樘峁┝四恕埂９式
和重之g有著一Nc生俱淼年PS。式是你希望到_的目耍重t是到_
之路。本K]有提供「助你完成所有知名式」的重手法，甚至B GoF 的23
知名式 [Gang of Four] 都]有能蛉部涵w。@也哪角度反映出@份名
的不完整。我希望有一天@缺陷能虮惶钛a。
\用重的r候，住：它HH是一起c。毋庸置疑，你一定可以找出w
中缺陷。我之所以x瘳F在l表它，因槲蚁嘈牛管它不完美，但的_
有用。我相信它能o你一起c，然後你可以不嗵岣咦约旱闹能力。@正
是它Ыo我的。
S著你用^愈碛多的重手法，我希望，你也_始l展凫赌阕约旱闹手法。
但本例子能蚣ぐl你的造力，Ko你一起c，你知道暮稳胧帧Ｎ液
清楚F存在的重，比我@e介B的要多得多。如果你真的提出了一些新的
重手法，o我一封子]件。
Refactoring C Improving the Design of Existing Code
108
Refactoring C Improving the Design of Existing Code
109
第6 章 重新M你的函式6
重新M你的函式
Composing Methods
我的重手法中，很大一部分是函式M行整理，使之更恰地包b程式a。
乎所有r刻，}都源於Long Methods（^L函式）。@很，因它往往
包含太多Y，@些Y又被函式eC}s的掩w，不易ae。Ω哆^L函
式，一重要的重手法就是Extract Method（110），它把一段程式a脑先函
式中提取出恚放M一为函式中。Inline Method（117）正好相反：⒁函
式呼叫幼魈Q樵函式本w。如果在M行多次提之後，意R到提所得的某
些函式K]有做任何|事情，或如果需要回溯恢驮先函式，我就需要Inline
Method（117）。
Extract Method（110）最大的困y就是理^域担而rt是其中一
主要的困y源^。理一函式r，我喜g\用Replace Temp with Query（120）
去掉所有可去掉的r怠Ｈ绻很多地方使用了某r担我就先\用
Split Temporary Variable（128）⑺得比^容易替Q。
但有r候r在太混y，y以替Q。@r候我就需要使用Replace Method
with Method Object（135）。它我可以分解哪怕最混y的函式，代rt是引入
一新class。
淼}比r瞪晕⑸僖恍，前提是你不在函式荣x值o它。如果
你已@幼隽耍就得使用Remove Assignments to Parameters（131）。
函式分解完後，我就可以知道如何它工作得更好。也S我lF演算法可
以改M，亩使程式a更清晰。@r我就使用Substitute Algorithm（139）引入更
清晰的演算法。
第6 章 重新M你的函式
Refactoring C Improving the Design of Existing Code
110
6.1 Extract Method
你有一段程式a可以被M在一起K立出怼
⑦@段程式a放M一立函式中，K函式名Q解函式的用途。
void printOwing(double amount) {
printBanner();
//print details
System.out.println ("name:" + _name);
System.out.println ("amount" + amount);
}
"
void printOwing(double amount) {
printBanner();
printDetails(amount);
}
void printDetails (double amount) {
System.out.println ("name:" + _name);
System.out.println ("amount" + amount);
}
C（Motivation）
Extract Method是我最常用的重手法之一。我看一^L的函式或者一段需
要注才能人理解用途的程式a，我就⑦@段程式a放M一立函式中。
有原因造成我喜g短而有良好命名的函式。首先，如果每函式的粒度都
很小（finely grained），那麽函式之g彼此陀玫C就更大；其次，@使高A
函式ax起砭拖褚幌盗凶⑨；再者，如果函式都是粒度，那麽函式的覆
（override）也更容易些。
的_，如果你T看大型函式，恐怕需要一段rg才能m@N新L格。而且只
有你能o小型函式很好地命名r，它才能真正起作用，所以你需要在函式名
Q下c功夫。人有r我，一函式多L才算合m？在我看恚L度不是
6.1 Extract Method
Refactoring C Improving the Design of Existing Code
111
}，PI在於函式名Q和函式本w之g的Z意距x（semantic distance）。如果提
幼鳎extracting）可以化程式a的清晰度，那就去做，就算函式名Q比提
出淼某淌酱aL也o所^。
作法（Mechanics）
# 造一新函式，根@函式的意D斫o它命名（以它「做什麽」砻名，
而不是以它「怎幼觥姑名）。
$ 即使你想要提（extract）的程式a非常危例如只是一l息或
一函式呼叫，只要新函式的名Q能蛞愿好方式昭示程式a意D，
你也提它。但如果你想不出一更有意x的名Q，就e印
# ⑻出的程式a脑春式（source）拷到新建的目撕式（target）中。
# 仔z查提出的程式a，看看其中是否引用了「作用域（scope）限於源函
式」的担ò括^域岛驮春式担。
# z查是否有「H用於被提a」的r担temporary variables）。如果有，
在目撕式中⑺宣告r怠
# z查被提a，看看是否有任何^域担local-scope variables）的值被它
改。如果一r抵当恍薷牧耍看看是否可以⒈惶a理一
查（query），K⒔Y果x值o相P怠Ｈ绻很y@幼觯或如果被修改
的挡恢挂，你就不能HH⑦@段程式a原封不拥靥出怼Ｄ憧赡
需要先使用Split Temporary Variable（128），然後再L提。也可以使
用Replace Temp with Query（120）r迪绲簦ㄕ看「例」中的
）。
# ⒈惶a中需要x取的^域担做鹘o目撕式。
# 理完所有^域抵後，M行g。
# 在源函式中，⒈惶a替Q椤δ撕式的呼叫」。
$ 如果你⑷魏r狄频侥撕式中，z查它原本的宣告式
是否在被提a的外。如果是，F在你可以删除@些宣告式了。
# g，y。
第6 章 重新M你的函式
Refactoring C Improving the Design of Existing Code
112
例（Examples）：o^域担No Local Variables）
在最蔚那r下，Extract Method（110）易如反掌。看下列函式：
void printOwing() {
Enumeration e = _orders.elements();
double outstanding = 0.0;
// print banner
System.out.println ("**************************");
System.out.println ("***** Customer Owes ******");
System.out.println ("**************************");
// calculate outstanding
while (e.hasMoreElements()) {
Order each = (Order) e.nextElement();
outstanding += each.getAmount();
}
//print details
System.out.println ("name:" + _name);
System.out.println ("amount" + outstanding);
}
我可以p提出「列印banner」的程式a。我只需要剪下、N上、再插入一
函式呼叫幼骶托辛耍
void printOwing() {
Enumeration e = _orders.elements();
double outstanding = 0.0;
printBanner();
// calculate outstanding
while (e.hasMoreElements()) {
Order each = (Order) e.nextElement();
outstanding += each.getAmount();
}
//print details
System.out.println ("name:" + _name);
System.out.println ("amount" + outstanding);
}
void printBanner() {
// print banner
System.out.println ("**************************");
System.out.println ("***** Customer Owes ******");
System.out.println ("**************************");
}
6.1 Extract Method
Refactoring C Improving the Design of Existing Code
113
例（Examples）：有^域担Using Local Variables）
果真@N危@重手法的困yc在哪e？是的，就在^域担包括鬟M
源函式的岛驮春式所宣告的r怠^域档淖饔糜H限於源函式，所
以我使用Extract Method（110）r，必花M~外功夫去理@些怠Ｄ承
r候它甚至可能妨K我，使我根本o法M行@重。
^域底詈蔚那r是：被提a只是x取@些档闹担K不修改它。@
N情r下我可以蔚⑺做鹘o目撕式。所以如果我面ο铝泻式：
void printOwing() {
Enumeration e = _orders.elements();
double outstanding = 0.0;
printBanner();
// calculate outstanding
while (e.hasMoreElements()) {
Order each = (Order) e.nextElement();
outstanding += each.getAmount();
}
//print details
System.out.println ("name:" + _name);
System.out.println ("amount" + outstanding);
}
我就可以「列印Y」@一部分提「б档暮式」：
void printOwing() {
Enumeration e = _orders.elements();
double outstanding = 0.0;
printBanner();
// calculate outstanding
while (e.hasMoreElements()) {
Order each = (Order) e.nextElement();
outstanding += each.getAmount();
}
printDetails(outstanding);
}
void printDetails (double outstanding) {
System.out.println ("name:" + _name);
System.out.println ("amount" + outstanding);
}
必要的，你可以用@N手法理多^域怠
第6 章 重新M你的函式
Refactoring C Improving the Design of Existing Code
114
如果^域凳物件，而被提a呼叫了υ物件造成修改的函式，也可以
如法炮u。你同又恍⑦@物件作鬟fo目撕式即可。只有在被提
a真的σ^域蒂x值的情r下，你才必袢∑渌措施。
例（Examples）：^域翟儋x值（Reassigning）
如果被提a^域蒂x值，}就得}s了。@e我只r档
}。如果你lF源函式的当毁x值，R上使用Remove Assignments to
Parameters（131）。
被x值的r狄卜煞N情r。^蔚那r是：@抵辉诒惶a^段
中使用。果真如此，你可以⑦@r档男告式移到被提a中，然後一起
提出去。另一N情r是：被提a之外的程式a也使用了@怠＿@又分
煞N情r：如果@翟诒惶a之後未再被使用，你只需直接在目撕式中
修改它就可以了；如果被提a之後的程式a使用了@担你就需要目
撕式返回蹈淖後的值。我以下列程式af明@追N不同情r：
void printOwing() {
Enumeration e = _orders.elements();
double outstanding = 0.0;
printBanner();
// calculate outstanding
while (e.hasMoreElements()) {
Order each = (Order) e.nextElement();
outstanding += each.getAmount();
}
printDetails(outstanding);
}
F在我把「算」程式a提出恚
void printOwing() {
printBanner();
double outstanding = getOutstanding();
printDetails(outstanding);
}
double getOutstanding() {
Enumeration e = _orders.elements();
double outstanding = 0.0;
while (e.hasMoreElements()) {
Order each = (Order) e.nextElement();
outstanding += each.getAmount();
}
return outstanding;
}
6.1 Extract Method
Refactoring C Improving the Design of Existing Code
115
Enumeration e 只在被提a中用到，所以我可以⑺整搬到新函式中。
double outstanding 在被提a韧舛急挥玫剑所以我必提出淼
新函式骰厮。gy完成後，我就把回髦蹈拿，遵循我的一命名原t：
double getOutstanding() {
Enumeration e = _orders.elements();
double result = 0.0;
while (e.hasMoreElements()) {
Order each = (Order) e.nextElement();
result = each.getAmount();
}
return result;
}
本例中的outstanding 抵皇呛渭地被初始化一明_初值，所以我可以
只在新函式中λ初始化。如果程式a@底隽似渌理，我就必
它的值作鹘o目撕式。於@N化，最初程式a可能是@樱
void printOwing(double previousAmount) {
Enumeration e = _orders.elements();
double outstanding = previousAmount * 1.2;
printBanner();
// calculate outstanding
while (e.hasMoreElements()) {
Order each = (Order) e.nextElement();
outstanding += each.getAmount();
}
printDetails(outstanding);
}
提後的程式a可能是@樱
void printOwing(double previousAmount) {
double outstanding = previousAmount * 1.2;
printBanner();
outstanding = getOutstanding(outstanding);
printDetails(outstanding);
}
double getOutstanding(double initialValue) {
double result = initialValue;
Enumeration e = _orders.elements();
while (e.hasMoreElements()) {
Order each = (Order) e.nextElement();
result += each.getAmount();
}
return result;
}
第6 章 重新M你的函式
Refactoring C Improving the Design of Existing Code
116
gKy後，我再⒆outstanding的初始化^程整理一下：
void printOwing(double previousAmount) {
printBanner();
double outstanding = getOutstanding(previousAmount * 1.2);
printDetails(outstanding);
}
@r候，你可能：『如果需要骰氐淖挡恢挂，又怎麽k呢？』
你有捣Nx瘛Ｗ詈玫倪x裢ǔＪ牵禾暨x另一K程式a硖。我比^喜g每
函式都只骰匾值，所以我安排多函式，用以骰囟值。如果你使用
的Z言支援「出式怠梗output parameters），你可以使用它Щ囟回
值。但我是可能x我换胤抵怠
r低往敌\多，甚至使提工作e步SD。@N情r下，我L先
\用Replace Temp with Query（120）p少r怠Ｈ绻即使@N做了提依f
困y重重，我就佑Replace Method with Method Object（135），@重手
法不在乎程式a中有多少r担也不在乎你如何使用它。
6.2 Inline Method
Refactoring C Improving the Design of Existing Code
117
6.2 Inline Method
一函式，其本w（method body）c其名Q（method name）同忧宄易懂。
在函式呼叫c插入函式本w，然後移除函式。
int getRating() {
return (moreThanFiveLateDeliveries()) ? 2 : 1;
}
boolean moreThanFiveLateDeliveries() {
return _numberOfLateDeliveries > 5;
}
"
int getRating() {
return (_numberOfLateDeliveries > 5) ? 2 : 1;
}
C（Motivation）
本常以短的函式表F幼饕D，@使程式a更清晰易x。但有r候你
遇到某些函式，其炔砍淌酱a和函式名Q同忧逦易x。也可能你重了函
式，使得其热莺推涿Q得同忧逦。果真如此，你就去掉@函式，直
接使用其中的程式a。g接性可能椭，但非必要的g接性是人不舒服。
另一N需要使用Inline Method（117）的情r是：你手上有一群M不甚合理的函
式。你可以⑺都inlining 到一大型函式中，再闹刑出M合理的小型函
式。Kent BecklF，施Replace Method with Method Object（135）之前先@N
做，往往可以@得不e的效果。你可以把你所要的函式（有著你要的行椋┑乃
有呼叫ο蟮暮式热荻inlining 到method object（函式物件）中。比起既要移
一函式，又要移铀所呼叫的其他所有函式，「⒋笮秃式作我徽w硪
印比^巍
如果e人使用了太多g接樱使得系y中的所有函式都似乎只是α硪函式的
挝（delegation），造成我在@些委幼髦g^D向，那麽我通常都
使用Inline Method（117）。然，g接佑衅r值，但不是所有g接佣加r值。
著使用inline，我可以找到那些有用的g接樱同r⒛切o用的g接酉除掉。
第6 章 重新M你的函式
Refactoring C Improving the Design of Existing Code
118
作法（Mechanics）
# z查函式，_定它不具多型性（is not polymorphic）。
$ 如果subclass^承了@函式，就不要⒋撕式inline化，因subclass
o法覆（override）一根本不存在的函式。
# 找出@函式的所有被呼叫c。
# ⑦@函式的所有被呼叫c都替Q楹式本w（程式a）。
# g，y。
# 删除函式的定x。
被我@右，Inline Method（117）似乎很巍５情r往往K非如此。於f
呼叫、多回返c、inlining 至另一物件中而物件Ko提供存取函式
（accessors）…，每一N情r我都可以上好醉。我之所以不@些特殊情r，
原因很危喝绻你遇到了@拥难}s情r，那麽就不使用@重手法。
6.3 Inline Temp
Refactoring C Improving the Design of Existing Code
119
6.3 Inline Temp
你有一r担只被一芜\算式x值一次，而它妨K了其他重手法。
⑺有υ档囊用幼鳎替Qλx值的那\算式本身。
double basePrice = anOrder.basePrice();
return (basePrice > 1000)
"
return (anOrder.basePrice() > 1000)
C（Motivation）
Inline Temp（119）多半是作Replace Temp with Query（120）的一部分硎褂茫
所以真正的C出F在後者那骸Ｎ┮为使用Inline Temp（119）的情r是：你
lF某r当毁x予某函式呼叫的回返值。一般碚f，@拥r挡
有任何危害，你可以放心地把它留在那骸５如果@r捣恋K了其他的
重手法 ― 例如Extract Method（110），你就⑺inline 化。
作法（Mechanics）
# 如果@rK未被宣告final，那就⑺宣告final，然後g。
$ @可以z查r凳欠裾娴闹槐毁x值一次。
# 找到r档乃有引用c，⑺替Q椤r蒂x值」之述句中
的等右冗\算式。
# 每次修改後，gKy。
# 修改完所有引用c之後，删除r档男告式和x值述句。
# g，y。
第6 章 重新M你的函式
Refactoring C Improving the Design of Existing Code
120
6.4 Replace Temp with Query
你的程式以一r担temp）保存某一\算式的\算Y果。
⑦@\算式提到一立函式（g]：所^查式，query）中。⑦@r
档乃有「被引用c」替Q椤π潞式的呼叫」。新函式可被其他函式使用。
double basePrice = _quantity * _itemPrice;
if (basePrice > 1000)
return basePrice * 0.95;
else
return basePrice * 0.98;
"
if (basePrice() > 1000)
return basePrice() * 0.95;
else
return basePrice() * 0.98;
...
double basePrice() {
return _quantity * _itemPrice;
}
C（Motivation）
r档}在於：它是r的，而且只能在所俸式仁褂谩Ｓ伸r
抵挥性谒俸式炔趴梢，所以它使你出更L的函式，因只有@
你才能存取到想要存取的r怠Ｈ绻把r堤Q橐查式（query
method），那麽同一class 中的所有函式都⒖梢垣@得@份Y。@Ыo你O
大椭，使你能@class 更清晰的程式a。
Replace Temp with Query（120）往往是你\用Extract Method（110）之前必不可
少的一步E。^域使程式ay以被提，所以你可能把它替Q
椴樵式。
@重手法^橹甭实那r就是：r抵槐毁x值一次，或者x值or
档倪\算式不受其他l件影。其他情r比^棘手，但也有可能l生。你可能需
要先\用Split Temporary Variable（128）或Separate Query from Modifier（279）
使情r得我恍，然後再替Qr怠Ｈ绻你想替Q的r凳怯硎
6.4 Replace Temp with Query
Refactoring C Improving the Design of Existing Code
121
集Y果的（例如圈中的累加值），你就需要⒛承┏淌竭（例如圈）拷
到查式（query method）去。
作法（Mechanics）
首先是吻r：
# 找出只被x值一次的r怠
$ 如果某r当毁x值超^一次，考]使用Split Temporary
Variable（128）⑺分割成多怠
# ⒃r敌告final。
# g。
$ @可_保r档拇_只被x值一次。
# 「υr蒂x值」之述句的等右炔糠痔到一立函式中。
$ 首先⒑式宣告private。日後你可能lF有更多class 需要使用
它，彼r你可p易放λ的保o。
$ _保提出淼暮式o任何Bв绊（副作用），也就是f函式
K不修改任何物件热荨Ｈ绻它有Bв绊，就λM行Separate
Query from Modifier（279）。
# g，y。
# 在r瞪砩施Inline Temp（119）。
我常常使用r当４孓圈中的累加Y。在@N情r下，整圈都可以
被提橐立函式，@也使原本的函式可以少掉仔_人的圈a。有r候，
你可能用我晦圈累加好值，就像本 p.26 的例子那印＿@N情r下你
γ累加值重}一遍圈，@泳涂梢⑺有r刀继Q椴樵式
（query）。然，圈很危}u@些程式ar才不砦ｋU。
\用此手法，你可能心效率}。和其他效率}一樱我F在不管它，
因它十有八九根本不造成任何影。如果效率真的出了}，你也可以在最
佳化r期解Q它。如果程式aM良好，那麽你往往能虬lF更有效的最佳化方
案；如果你]有M行重，好的最佳化方案就可能c你失之交臂。如果效率在
太糟糕，要把r捣呕厝ヒ彩呛苋菀椎摹
第6 章 重新M你的函式
Refactoring C Improving the Design of Existing Code
122
例（Example）
首先，我囊魏式_始：
double getPrice() {
int basePrice = _quantity * _itemPrice;
double discountFactor;
if (basePrice > 1000) discountFactor = 0.95;
else discountFactor = 0.98;
return basePrice * discountFactor;
}
我希望r刀继Q掉。然，每次一。
管@e的程式a十分清楚，我是先把r敌告final，z查它是否的
_只被x值一次：
double getPrice() {
final int basePrice = _quantity * _itemPrice;
final double discountFactor;
if (basePrice > 1000) discountFactor = 0.95;
else discountFactor = 0.98;
return basePrice * discountFactor;
}
@N一恚如果有任何}，g器就警告我。之所以先做@件事，因如果
r挡恢槐毁x值一次，我就不M行@重。接下砦议_始替Qr担
每次一。首先我把x值（assignment）幼鞯挠冗\算式提出恚
double getPrice() {
final int basePrice = basePrice();
final double discountFactor;
if (basePrice > 1000) discountFactor = 0.95;
else discountFactor = 0.98;
return basePrice * discountFactor;
}
private int basePrice() {
return _quantity * _itemPrice;
}
gKy，然後_始使用Inline Temp（119）。首先把rbasePrice 的
第一引用c替Q掉：
double getPrice() {
final int basePrice = basePrice();
final double discountFactor;
if (basePrice() > 1000) discountFactor = 0.95;
else discountFactor = 0.98;
return basePrice * discountFactor;
}
6.4 Replace Temp with Query
Refactoring C Improving the Design of Existing Code
123
g、y、下一（起硐裨谥]人跳l村舞蹈一樱。由於「下一」
已是basePrice 的最後一引用c，所以我把basePrice r档男告式一
阏除：
double getPrice() {
final double discountFactor;
if (basePrice() > 1000) discountFactor = 0.95;
else discountFactor = 0.98;
return basePrice() * discountFactor;
}
搞定basePrice之後，我再以似k法提出一discountFactor()：
double getPrice() {
final double discountFactor = discountFactor();
return basePrice() * discountFactor;
}
private double discountFactor() {
if (basePrice() > 1000) return 0.95;
else return 0.98;
}
你看，如果我]有把rbasePrice 替Q橐查式，⒍帱Ny以提
discountFactor()！
最K，getPrice()成了@樱
double getPrice() {
return basePrice() * discountFactor();
}
第6 章 重新M你的函式
Refactoring C Improving the Design of Existing Code
124
6.5 Introduce Explaining Variable
你有一}s的\算式。
⒃}s\算式（或其中一部分）的Y果放M一r担以此得Q斫
\算式用途。
if ( (platform.toUpperCase().indexOf("MAC") > -1) &&
(browser.toUpperCase().indexOf("IE") > -1) &&
wasInitialized() && resize > 0 )
{
// do something
}
"
final boolean isMacOs = platform.toUpperCase().indexOf("MAC") > -1;
final boolean isIEBrowser = browser.toUpperCase().indexOf("IE") > -1;
final boolean wasResized = resize > 0;
if (isMacOs && isIEBrowser && wasInitialized() && wasResized) {
// do something
}
C（Motivation）
\算式有可能非常}s而y以x。@N情r下，r悼梢椭你⑦\算式
分解楸容^容易管理的形式。
在l件（conditional logic）中，Introduce Explaining Variable（124）特e有
r值：你可以用@重⒚l件子句提出恚以一良好命名的r
斫忉l件子句的意x。使用@重的另一N情r是，在^L演算法中，
可以\用r斫忉每一步\算的意x。
Introduce Explaining Variable（124）是一很常的重手法，但我得承J，我
K不常用它。我缀蹩是量使用Extract Method（110）斫忉一段程式a的意
x。竟r抵辉谒所的那函式中才有意x，I限性^大，函式t可以
在物件的整生命中都有用，K且可被其他物件使用。但有r候，^域凳
Extract Method（110）y以M行r，我就使用Introduce Explaining Variable（124）。
6.5 Introduce Explaining Variable
Refactoring C Improving the Design of Existing Code
125
作法（Mechanics）
# 宣告一final r担⒋分解之}s\算式中的一部分幼鞯倪\算Y果
x值o它。
# ⑦\算式中的「\算Y果」@一部分，替Q樯鲜r怠
$ 如果被替Q的@一部分在程式a中重}出F，你可以每次一，逐
一替Q。
# g，y。
# 重}上述^程，理\算式的其他部分。
例（Examples）
我囊斡算_始：
double price() {
// price is base price - quantity discount + shipping
return _quantity * _itemPrice -
Math.max(0, _quantity - 500) * _itemPrice * 0.05 +
Math.min(_quantity * _itemPrice * 0.1, 100.0);
}
@段程式a算危不^我可以它得更容易理解。首先我lF，底r（base
price）等於盗浚quantity）乘以r（item price）。於是我把@一部分算的Y
果放M一r抵校
double price() {
// price is base price - quantity discount + shipping
final double basePrice = _quantity * _itemPrice;
return basePrice -
Math.max(0, _quantity - 500) * _itemPrice * 0.05 +
Math.min(_quantity * _itemPrice * 0.1, 100.0);
}
稍後也用上了「盗砍艘r」\算Y果，所以我同⑺替QbasePrice 
r担
double price() {
// price is base price - quantity discount + shipping
final double basePrice = _quantity * _itemPrice;
return basePrice -
Math.max(0, _quantity - 500) * _itemPrice * 0.05 +
Math.min(basePrice * 0.1, 100.0);
}
第6 章 重新M你的函式
Refactoring C Improving the Design of Existing Code
126
然後，我⑴l折扣（quantity discount）的算提出恚⒔Y果x予r
quantityDiscount：
double price() {
// price is base price - quantity discount + shipping
final double basePrice = _quantity * _itemPrice;
final double quantityDiscount = Math.max(0, _quantity - 500) *
_itemPrice * 0.05;
return basePrice - quantityDiscount +
Math.min(basePrice * 0.1, 100.0);
}
最後，我再把\M（shipping）算提出恚⑦\算Y果x予rshipping。
同r我可以删掉程式a中的注，因F在程式a已可以完美表_自己的意
x了：
double price() {
final double basePrice = _quantity * _itemPrice;
final double quantityDiscount = Math.max(0, _quantity - 500) *
_itemPrice * 0.05;
final double shipping = Math.min(basePrice * 0.1, 100.0);
return basePrice - quantityDiscount + shipping;
}
\用Extract Method 理上述例
面ι鲜龀淌酱a，我通常不以r斫忉其幼饕D，我更喜g使用Extract
Method（110）。我回到起c：
double price() {
// price is base price - quantity discount + shipping
return _quantity * _itemPrice -
Math.max(0, _quantity - 500) * _itemPrice * 0.05 +
Math.min(_quantity * _itemPrice * 0.1, 100.0);
}
@一次我把底r算提到一立函式中：
double price() {
// price is base price - quantity discount + shipping
return basePrice() -
Math.max(0, _quantity - 500) * _itemPrice * 0.05 +
Math.min(basePrice() * 0.1, 100.0);
}
private double basePrice() {
return _quantity * _itemPrice;
}
6.5 Introduce Explaining Variable
Refactoring C Improving the Design of Existing Code
127
我^m我的提，每次提出一新函式。最後得到下列程式a：
double price() {
return basePrice() - quantityDiscount() + shipping();
}
private double quantityDiscount() {
return Math.max(0, _quantity - 500) * _itemPrice * 0.05;
}
private double shipping() {
return Math.min(basePrice() * 0.1, 100.0);
}
private double basePrice() {
return _quantity * _itemPrice;
}
我比^喜g使用Extract Method（110），因同一物件中的任何部分，都可以根
自己的需要去取用@些提出淼暮式。一_始我把@些新函式宣告
private；如果其他物件也需要它，我可以p易放@些函式的存取限制。我l
F，Extract Method（110）的工作量通常K不比Introduce Explaining Variable（124）
淼么蟆
那麽，在什麽r候使用Introduce Explaining Variable（124）呢？答案是：在
Extract Method（110）需要花M更大工作量r。如果我要理的是一碛写罅
^域档难菟惴ǎ那麽使用Extract Method（110）^非易事。@N情r下我
使用Introduce Explaining Variable（124）椭我理清程式a，然後再考]下一步
怎麽k。搞清楚程式a之後，我是可以\用Replace Temp with Query
（120）把被我引入的那些解性r等サ簟r且，如果我最K使用Replace
Method with Method Object（135），那麽被我引入的那些解性r狄灿衅
r值。
第6 章 重新M你的函式
Refactoring C Improving the Design of Existing Code
128
6.6 Split Temporary Variable（剖解r担
你的程式有某r当毁x值超^一次，它既不是圈担也不是一集用
r担collecting temporary variable）。
γ看钨x值，造一立的、的r怠
double temp = 2 * (_height + _width);
System.out.println (temp);
temp = _height * _width;
System.out.println (temp);
"
final double perimeter = 2 * (_height + _width);
System.out.println (perimeter);
final double area = _height * _width;
System.out.println (area);
C（Motivation）
r涤懈鞣N不同用途，其中某些用途很自然地еr当欢啻钨x值。
「圈怠购汀讣用r怠咕褪典型例子：圈担loop variable）[Beck]
S圈的每次绦卸改（例如for (int i=0; i<10; i++)述句中的i）；
集用r担collecting temporary variable）[Beck] 「由整函式的\
算」而成的某值收集起怼
除了@煞N情r，有很多r涤渺侗４嬉欢稳唛L程式a的\算Y果，以便
稍後使用。@Nr只被x值一次。如果它被x值超^一次，就意味
它在函式中承了一以上的任。如果r党多任，它就被
替Q（剖解）槎r担每抵怀一任。同一r党
杉不同的事情，令程式ax者糊T。
作法（Mechanics）
# 在「待剖解」之r档男告式及其第一次被x值，修改其名Q。
$ 如果稍後之x值述句是「i = i + 某\算式」@N形式，就意味@
是集用r担那麽就不要剖解它。集用r档淖饔猛ǔ
是累加、字串接合、入stream、或者向群集（collection）添加元素。
6.6 Split Temporary Variable（剖解r担
Refactoring C Improving the Design of Existing Code
129
# ⑿碌r敌告final。
# 以r抵第二次x值幼界，修改此前υr档乃有引用
c，它引用新的r怠
# 在第二次x值，重新宣告原先那r怠
# g，y。
# 逐次重}上述^程。每次都在宣告r狄酌，K修改下次x值之前
的引用c。
例（Examples）
下面例中我要算一K格m布丁（haggis）\拥木嚯x。在起c，o止的K
格m布丁受到一初始力的作用而_始\印Ｒ欢rg後，第二力作用於布
丁，它再次加速。根牛D第二定律，我可以@佑算布丁\拥木嚯x：
double getDistanceTravelled (int time) {
double result;
double acc = _primaryForce / _mass; // g]：第一次x值
int primaryTime = Math.min(time, _delay);
result = 0.5 * acc * primaryTime * primaryTime;
int secondaryTime = time - _delay;
if (secondaryTime > 0) {
double primaryVel = acc * _delay; // g]：以下是第二次x值
acc = (_primaryForce + _secondaryForce) / _mass;
result += primaryVel * secondaryTime + 0.5 * acc * secondaryTime
* secondaryTime;
}
return result;
}
真是^佳的h陋小|西。注意^察此例中的acc 等绾伪毁x值纱巍acc 
涤任：第一是保存第一力造成的初始加速度；第二是保存力共同
造成的加速度。@就是我想要剖解的|西。
首先，我在函式_始修改@r档拿Q，K⑿碌r敌告final。
接下砦野训诙次x值之前acc 档乃有引用c，全部改用新的r怠
最後，我在第二次x值重新宣告acc担
double getDistanceTravelled (int time) {
double result;
final double primaryAcc = _primaryForce / _mass;
int primaryTime = Math.min(time, _delay);
result = 0.5 * primaryAcc * primaryTime * primaryTime;
int secondaryTime = time - _delay;
第6 章 重新M你的函式
Refactoring C Improving the Design of Existing Code
130
if (secondaryTime > 0) {
double primaryVel = primaryAcc * _delay;
double acc = (_primaryForce + _secondaryForce) / _mass;
result += primaryVel * secondaryTime + 0.5 * acc * secondaryTime
* secondaryTime;
}
return result;
}
新的r档拿Q指出，它只承原先acc 档牡谝任。我⑺宣告
final，_保它只被x值一次。然後，我在原先acc 档诙次被x值重新宣告
acc。F在，重新gKy，一切都]有}。
然後，我^m理acc r档牡诙次x值。@次我把原先的r低耆删
掉，代之以一新的r怠Ｐ伦档拿Q指出，它只承原先acc 档牡
二任：
double getDistanceTravelled (int time) {
double result;
final double primaryAcc = _primaryForce / _mass;
int primaryTime = Math.min(time, _delay);
result = 0.5 * primaryAcc * primaryTime * primaryTime;
int secondaryTime = time - _delay;
if (secondaryTime > 0) {
double primaryVel = primaryAcc * _delay;
final double secondaryAcc = (_primaryForce + _secondaryForce)
/ _mass;
result += primaryVel * secondaryTime + 0.5 *
secondaryAcc * secondaryTime * secondaryTime;
}
return result;
}
F在，@段程式a肯定可以你想起更多其他重手法。M情享受吧。（我敢保
C，@比吃K格m布丁强多了 ― 你知道他都在Y面放了些什麽|西幔4）
4 g注：K格m布丁（haggis）是一NK格m菜，把羊心等扰Kb在羊胃Y煮成。由於
它被羊胃包成一球w，因此可以像球一犹硖呷ィ@就是本例的由怼！赴蜒蛐
b在羊胃Y煮成…」，呃，有些人y免@道菜f心，Martin Fowler 想必是其中之一。
6.7 Remove Assignments to Parameters
Refactoring C Improving the Design of Existing Code
131
6.7 Remove Assignments to Parameters
你的程式aσ颠M行x值幼鳌
以一r等〈档奈恢谩
int discount (int inputVal, int quantity, int yearToDate) {
if (inputVal > 50) inputVal -= 2;
"
int discount (int inputVal, int quantity, int yearToDate) {
int result = inputVal;
if (inputVal > 50) result -= 2;
C（Motivation）
首先，我要_定大家都清楚「蒂x值」@f法的意思。如果你把一名foo
的物件作鹘o某函式，那麽「蒂x值」意味改foo，使它引用（
考、指涉、指向）另一物件。如果你在「被魅胛锛」身上M行什麽操作，那
]}，我也是@帧Ｎ抑会Αfoo 被改而指向（引用）完全不同的另一
物件」@N情r碛：
void aMethod(Object foo) {
foo.modifyInSomeWay(); // that's OK
foo = anotherObject; // trouble and despair will follow you
我之所以不喜g@拥淖鞣ǎ因它降低了程式a的清晰度，而且混淆了pass by
value（髦担┖pass by reference（髦罚┻@煞N鬟f方式。Java 只裼pass by
value鬟f方式（稍後），我的也正是基於@一c。
在pass by value 情r下，档娜魏涡薷模都不呼叫端造成任何影。那
些用^pass by reference的人可能在@一c上犯糊T。
另一人糊T的地方是函式本w取Ｈ绻你只以当硎尽副鬟fM淼|西」，
那麽程式a清晰得多，因@N用法在所有Z言中都表F出相同Z意。
在Java 中，不要蒂x值；如果你看到手上的程式a已@幼隽耍使用
Remove Assignments to Parameters（131）。
然，面δ切┦褂谩篙出式怠梗output parameters）的Z言，你不必遵循@
lt。不^在那些Z言中我量少用出式怠
第6 章 重新M你的函式
Refactoring C Improving the Design of Existing Code
132
作法（Mechanics）
# 建立一r担把待理的抵蒂x予它。
# 以「档馁x值幼鳌界，⑵溽崴有Υ档囊用c，全部替Q
「Υr档囊用幼鳌埂
# 修改x值述句，使其改π陆ㄖr蒂x值。
# g，y。
$ 如果程式a的Z意是pass by reference，在呼叫端z查呼叫後是否
使用了@怠Ｒ惨z查有多少pass by reference 怠副毁x
值後又被使用」。量只以return 方式骰匾值。如果需要回
返的值不只一，看看可否把需回返的大堆Y料成我晃锛，或
乾脆槊回返值O的一立函式。
例（Examples）
我南铝羞@段纬淌酱a_始：
int discount (int inputVal, int quantity, int yearToDate) {
if (inputVal > 50) inputVal -= 2;
if (quantity > 100) inputVal -= 1;
if (yearToDate > 10000) inputVal -= 4;
return inputVal;
}
以r等〈档馁x值幼鳎得到下列程式a：
int discount (int inputVal, int quantity, int yearToDate) {
int result = inputVal;
if (inputVal > 50) result -= 2;
if (quantity > 100) result -= 1;
if (yearToDate > 10000) result -= 4;
return result;
}
可以导由详PI字final，亩强制它遵循「不蒂x值」@一T例：
int discount (final int inputVal, final int quantity,
final int yearToDate) {
int result = inputVal;
if (inputVal > 50) result -= 2;
if (quantity > 100) result -= 1;
if (yearToDate > 10000) result -= 4;
return result;
}
6.7 Remove Assignments to Parameters
Refactoring C Improving the Design of Existing Code
133
不^我得承J，我K不常使用final 硇揎担因我lF，於提高短函式
的清晰度，@k法Ko太大椭。我通常在^L的函式中使用它，它椭
我z查凳欠癖蛔隽诵薷摹
Java 的pass by Value（髦担
Java 使用 "pass by value"「函式呼叫」方式，@常常造成S多人迷惑。在所有地c，
Java 都栏裼pass by value，所以下列程式：
class Param {
public static void main(String[] args) {
int x = 5;
triple(x);
System.out.println ("x after triple: " + x);
}
private static void triple(int arg) {
arg = arg * 3;
System.out.println ("arg in triple: " + arg);
}
}
a生@拥妮出：
arg in triple: 15
x after triple: 5
@段程式a不至於人糊T。但如果抵鬟f的是物件，就可能把人弄迷糊
了。如果我在程式中以Date物件表示日期，那麽下列程式：
class Param {
public static void main(String[] args) {
Date d1 = new Date ("1 Apr 98");
nextDateUpdate(d1);
System.out.println ("d1 after nextDay: " + d1);
Date d2 = new Date ("1 Apr 98");
nextDateReplace(d2);
System.out.println ("d2 after nextDay: " + d2);
}
private static void nextDateUpdate (Date arg) {
arg.setDate(arg.getDate() + 1);
System.out.println ("arg in nextDay: " + arg);
}
private static void nextDateReplace (Date arg) {
arg = new Date (arg.getYear(),arg.getMonth(),arg.getDate()+1);
System.out.println ("arg in nextDay: " + arg);
}
}
第6 章 重新M你的函式
Refactoring C Improving the Design of Existing Code
134
a生的出是：
arg in nextDay: Thu Apr 02 00:00:00 EST 1998
d1 after nextDay: Thu Apr 02 00:00:00 EST 1998
arg in nextDay: Thu Apr 02 00:00:00 EST 1998
d2 after nextDay: Wed Apr 01 00:00:00 EST 1998
谋举|上f，object reference 是按值鬟f的（pass by value）。因此我可以修改
滴锛的炔B，但滴锛重新x值，]有意x。
Java 1.1 及其後版本，允S你耸final，亩避免函式中蒂x值。
即使某当耸final，你仍然可以修改它所指向的物件。我是把狄
final，但是我得承J，我很少在盗校parameter list）中@耸舅。
6.8 Replace Method with Method Object
Refactoring C Improving the Design of Existing Code
135
6.8 Replace Method with Method Object
你有一大型函式，其中^域档氖褂茫使你o法裥Extract Method（110）。
⑦@函式放M一为物件中，如此一^域稻统闪宋锛鹊谖唬field）。
然後你可以在同一物件中⑦@大型函式分解小型函式。
class Order...
double price() {
double primaryBasePrice;
double secondaryBasePrice;
double tertiaryBasePrice;
// long computation;
...
}
"
PriceCalculator
primaryBasePrice
secondaryBasePrice
tertiaryBasePrice
compute
Order
Price()
return new PriceCalculator(this).compute()
1
C（Motivation）
我在本中不嘞蜃x者强{小型函式的美尤恕Ｖ灰⑾Κ立的程式a拇
型函式中提出恚就可以大大提高程式a的可x性。
但是，^域档拇嬖增加函式分解y度。如果一函式之中^域捣E成
模那麽想分解@函式是非常困y的。Replace Temp with Query（120）可以助
你pp@一，但有r候你lF根本o法拆解一需要拆解的函式。@N情
r下，你把手深深地伸入你的工具箱（好酒沉Y底呢），祭出函式物件（method
object）[Beck] @件法。
第6 章 重新M你的函式
Refactoring C Improving the Design of Existing Code
136
Replace Method with Method Object（135）⑺有^域刀甲成函式物件
（method object）的谖唬field）。然後你就可以@新物件使用Extract Method
（110）造出新函式，亩⒃本的大型函式拆解短。
作法（Mechanics）
我厚著皮Kent Beck [Beck] 那Y偷砹讼铝凶鞣ǎ
# 建立一新class，根「待被理之函式」的用途，檫@class 命名。
# 在新class 中建立一final 谖唬用以保存原先大型函式所v物件。我
@谖环Q「源物件」。同r，υ（f）函式的每r岛兔
担在新class中建立一的谖槐４嬷。
# 在新class 中建立一建式（constructor），接收源物件及原函式的所有
底怠
# 在新class中建立一compute()函式。
# ⒃（f）函式的程式a拷到compute()函式中。如果需要呼叫源物件的
任何函式，以「源物件」谖酒稹
# g。
# ⑴f函式的函式本w替Q檫@右l述句：「建上述新class 的一新物
件，而後呼叫其中的compute()函式」。
F在M行到很有趣的部分了。由於所有^域惮F在都成了谖唬所以你可以任
意分解@大型函式，不必鬟f任何怠
例（Examples）
如果要o@一重手法找合m例子，需要很L的篇幅。所以我以一不需要L
篇幅（那也就是f可能不十分完美）的例子展示@重。不要@函式的
是什麽，@完全是我且鹎易叩漠a品。
class Account...
int gamma (int inputVal, int quantity, int yearToDate) {
int importantValue1 = (inputVal * quantity) + delta();
int importantValue2 = (inputVal * yearToDate) + 100;
if ((yearToDate - importantValue1) > 100)
importantValue2 -= 20;
int importantValue3 = importantValue2 * 7;
// and so on.
return importantValue3 - 2 * importantValue1;
}
6.8 Replace Method with Method Object
Refactoring C Improving the Design of Existing Code
137
了把@函式成一函式物件（method object），我首先需要宣告一新class。
在此新class中我提供一final 谖挥靡员４嬖先物件（源物件）；於函式
的每一岛兔恳r担也以一谖恢鹨槐４妗
class Gamma...
private final Account _account;
private int inputVal;
private int quantity;
private int yearToDate;
private int importantValue1;
private int importantValue2;
private int importantValue3;
按T例，我通常以下Q作谖幻Q的字首。但了保持小步前M，我r
先保留@些谖坏脑名。
接下恚加入一建式：
Gamma (Account source, int inputValArg, int quantityArg,
int yearToDateArg) {
_account = source;
inputVal = inputValArg;
quantity = quantityArg;
yearToDate = yearToDateArg;
}
F在可以把原本的函式搬到 compute()了。函式中任何呼叫Account class 的地
方，我都必改而使用 _account谖唬
int compute () {
importantValue1 = (inputVal * quantity) + _account.delta();
importantValue2 = (inputVal * yearToDate) + 100;
if ((yearToDate - importantValue1) > 100)
importantValue2 -= 20;
int importantValue3 = importantValue2 * 7;
// and so on.
return importantValue3 - 2 * importantValue1;
}
然後，我修改f函式，它⑺的工作Dl（委，delegate）o完成的@函
式物件（method object）：
int gamma (int inputVal, int quantity, int yearToDate) {
return new Gamma(this, inputVal, quantity, yearToDate).compute();
}
第6 章 重新M你的函式
Refactoring C Improving the Design of Existing Code
138
@就是本重的基本原t。它淼暮锰是：F在我可以p地compute()
函式袢Extract Method（110），不必心引担argument）鬟f。
int compute () {
importantValue1 = (inputVal * quantity) + _account.delta();
importantValue2 = (inputVal * yearToDate) + 100;
importantThing();
int importantValue3 = importantValue2 * 7;
// and so on.
return importantValue3 - 2 * importantValue1;
}
void importantThing() {
if ((yearToDate - importantValue1) > 100)
importantValue2 -= 20;
}
6.9 Substitute Algorithm（替Q你的演算法）
Refactoring C Improving the Design of Existing Code
139
6.9 Substitute Algorithm（替Q你的演算法）
你想要把某演算法替Q榱硪更清晰的演算法。
⒑式本w（method body）替Q榱硪演算法。
String foundPerson(String[] people){
for (int i = 0; i < people.length; i++) {
if (people[i].equals ("Don")) {
return "Don";
}
if (people[i].equals ("John")) {
return "John";
}
if (people[i].equals ("Kent")) {
return "Kent";
}
}
return "";
}
"
String foundPerson(String[] people){
List candidates = Arrays.asList(new String[]
{"Don", "John", "Kent"});
for (int i=0; i<people.length; i++)
if (candidates.contains(people[i]))
return people[i];
return "";
}
C（Motivation）
我]^o猫皮，不^我f@有好追N方法，我敢打其中某些方法比另
一些巍Ｑ菟惴ㄒ彩侨绱恕Ｈ绻你lF做一件事可以有更清晰的方式，就
以^清晰的方式取代}s方式。「重」可以把一些}s|西分解檩^蔚男
K，但有r你就是必咽嗤螅删掉整演算法，代之以^蔚难菟惴āｋS
著}有了更多理解，你往往lF，在你的原先作法之外，有更蔚慕Q
方案，此r你就需要改原先的演算法。如果你_始使用程式欤而其中提供的
某些功能/特性c你自己的程式a重}，那麽你也需要改原先的演算法。
第6 章 重新M你的函式
Refactoring C Improving the Design of Existing Code
140
有r候你想要修改原先的演算法，它去做一件c原先幼髀杂胁町的事。@
r候你也可以先把原先的演算法替Q橐^易修改的演算法，@俞崂m的修改
pS多。
使用@重手法之前，先_定自己已可能分解了原先函式。替Q一巨
大而}s的演算法是非常困y的，只有先⑺分解檩^蔚男⌒秃式，然後你
才能很有把握地M行演算法替Q工作。
作法（Mechanics）
# 浜媚愕牧硪（替Q用）演算法，它通^g。
# ΜF有y，绦猩鲜龅男卵菟惴āＨ绻Y果c原本Y果相同，重Y束。
# 如果yY果不同於原先，在y和除e^程中，以f演算法比^⒄
省
$ 於每test case（y案例），分e以新f煞N演算法绦校K^
察烧呓Y果是否相同。@可以椭你看到哪一test case 出F麻，
以及出F了怎拥穆。
第6 章 重新M你的函式
Refactoring C Improving the Design of Existing Code
413
⒖目⒖目
References
[Auer]
Ken. Auer "Reusability through Self-Encapsulation." In Pattern Languages of Program
Design 1, Coplien J.O. Schmidt.D.C. Reading, Mass.: Addison-Wesley, 1995.
一篇有P於「自我封b」（self-encapsulation）概念的式文（patterns paper）。
[B.umer and Riehle]
B.umer, Riehle and Riehle. Dirk "Product Trader." In Pattern Languages of Program
Design 3, R. Martin F. Buschmann D. Riehle. Reading, Mass.: Addison-Wesley, 1998.
一式（patterns），用盱`活建物件而不需要知道物件`倌class。
[Beck]
Kent.Beck Smalltalk Best Practice Patterns. Upper Saddle River, N.J.: Prentice Hall,
1997a.
一本m合任何Smalltalker 的基本籍，也是一本θ魏挝锛向_l者很有用
的籍。{饔Java 版本。
[Beck, hanoi]
Kent.Beck "Make it Run, Make it Right: Design Through Refactoring."The Smalltalk
Report, 6: (1997b): 19-24.
第一本真正I悟「重^程如何\作」的出版品，也是《Refactoring》第一章S多
想的源^。
⒖目
Refactoring C Improving the Design of Existing Code
414
[Beck, XP]
Kent.Beck eXtreme Programming eXplained: Embrace Change. Reading, Mass.:
Addison-Wesley, 2000.
[Fowler, UML]
FowlerM.Scott.K. UML Distilled, Second Edition: A Brief Guide to the Standard Object
Modeling Language. Reading, Mass.: Addison-Wesley, 2000.
一本明扼要的б，助你了解《Refactoring》中各式各拥Unified Modeling
Language（UML，y一建模Z言）D片。
[Fowler, AP]
M.Fowler Analysis Patterns: Reusable Object Models. Reading, Mass.: Addison-Wesley,
1997.
一本domain model patternsＶ。包括range pattern 的一份。
[Gang of Four]
E. Gamma, R. Helm, R. Johnsonand J. Vlissides. Design Patterns: Elements of Reusable
Object Oriented Software. Reading, Mass.: Addison-Wesley, 1995.
或S是物件向O（object-oriented design）I域中最有r值的一本。F今
缀跞魏稳硕急仨Zе腔鄣卣cstrategy, singleton, 和chain of responsibility，
才敢f自己懂得物件（技g）。
[Jackson, 1993]
Jackson, Michael. Michael Jackson's Beer Guide, Mitchell Beazley, 1993.
一本有用的б，提供大量`（用性）研究。
[Java Spec]
Gosling, James, Bill Joy and Guy Steele. The Java Language Specification, Second
Edition. Boston, Mass.: Addison-Wesley, 2000.
所有Java }的官方答案。
[JUnit]
Beck, Kent, and Erich Gamma. JUnit Open-Source Testing Framework. Available on the
Web (http://www.junit.org).
撰Java 程式的基本用工具。是慰蚣埽framework），椭你撰、
M、绦卧y（unit tests）。似的框架也存在於Smalltalk 和C++ 中。
Refactoring C Improving the Design of Existing Code
415
[Lea]
Doug.Lea, Concurrent Programming in Java: Design Principles and Patterns, Reading,
Mass.: Addison-Wesley, 1997.
g器阻止任何人作Runnable介面 ― 如果他]有x^@本。
[McConnell]
Steve. McConnell, Code Complete: A Practical Handbook of Software Construction.
Redmond, Wash.: Microsoft Press, 1993.
一本於程L格和w建的卓越б。於Java Q生之前，但缀中的
所有忠告都m用於Java。
[Meyer]
Bertrand. Meyer, Object Oriented Software Construction. 2 ed. Upper Saddle River, N.J.:
Prentice Hall, 1997.
物件向O（object-oriented design）I域中一本很好（也很大）的籍。
其中包括於契s式O（design by contract）的一份氐子。
[Opdyke]
William F. Opdyke, Ph.D. diss., "Refactoring Object-Oriented Frameworks. " University
of Illinois at Urbana-Champaign, 1992.
⒁ftp://st.cs.uiuc.edu/pub/papers/refactoring/opdyke-thesis.ps.Z。是P於重的
第一份w面L度的著作。多少c教育和工具向的角度（竟@是一篇博士
文），於想更多了解重理的人，是很有r值的x物。
[Refactoring Browser]
Brant, John, and Don Roberts. Refactoring Browser Tool,
http://st-www.cs.uiuc.edu/~brant/RefactoringBrowser。未淼能w_l工具。
[Woolf]
Bobby. Woolf, "Null Object." In Pattern Languages of Program Design 3, Martin, R.
Riehle. D. Buschmann F. Reading, Mass.: Addison-Wesley, 1998.
null object pattern的一份。
⒖目
Refactoring C Improving the Design of Existing Code
416
Refactoring C Improving the Design of Existing Code
417
原音重F原音重F
List of Soundbites
p.7 When you find you have to add a feature to a program, and the program's code is not
structured in a convenient way to add the feature, first refactor the program to make it easy to
add the feature, then add the feature.
如果你lF自己需要槌淌教砑右特性，而程式aY使你o法很方便地那N
做，那就先重那程式，使特性的添加比^容易M行，然後再添加特性。
p.8 Before you start refactoring, check that you have a solid suite of tests. These tests must be
self-checking.
重前，先z查自己是否有一套可靠的yC制。@些y必有自我z能力。
p.13 Refactoring changes the programs in small steps. If you make a mistake, it is easy to find the bug.
重技gS以微小的步伐修改程式。如果你犯下e`，很容易便可lF它。
p.15 Any fool can write code that a computer can understand. Good programmers write code that
humans can understand.
任何一傻瓜都能出算C可以理解的程式a。惟有出人容易理解的程式
a，才是秀的程式T。
p.53 Refactoring (noun) : a change made to the internal structure of software to make it easier to
understand and cheaper to modify without changing its observable behavior of the software.
重（名~）：w炔拷Y的一N{整，目的是在不改「w之可察行椤
前提下，提高其可理解性，降低其修改成本。
p.54 Refactor (verb) : to restructure software by applying a series of refactorings without
changing the observable behavior of the software.
重（釉~）：使用一系列重t（手法），在不改「w之可察行椤骨疤
下，{整其Y。
原音重F
Refactoring C Improving the Design of Existing Code
418
p.58 Three strikes and you refactor.
事不^三，三t重。
p.65 Don't publish interfaces prematurely. Modify your code ownership policies to smooth refactoring.
不要^早l呀槊妗Ｕ修改你的程式a碛嗾策，使重更场
p.88 When you feel the need to write a comment, first try to refactor the code so that any comment
becomes superfluous.
你感X需要撰]，先L重，著所有]都得多N。
p.90 Make sure all tests are fully automatic and that they check their own results.
_保所有y都完全自踊，它z查自己的yY果。
p.90 A suite of tests is a powerful bug detector that decapitates the time it takes to find bugs.
一整My就是一大的臭xy器，能虼蟠罂sp搜こ粝x所需要的rg。
p.94 Run your tests frequently. Localize tests whenever you compile - every test at least every day.
l繁地绦y。每次g把y也考]M去 ― 每天至少绦忻y一次。
p.97 When you get a bug report, start by writing a unit test that exposes the bug.
每你接@臭x提螅先撰一卧y斫野l@b臭x。
p.98 It is better to write and run incomplete tests than not to run complete tests.
未臻完善的yKH绦校好^ν昝y的oM等待。
p.99 Think of the boundary conditions under which things might go wrong and concentrate your
tests there.
考]可能出e的界l件，把y火力集中在那骸
p.100 Don't forget to test that exceptions are raised when things are expected to go wrong.
事情被大家J出er，e忘了z查彼r是否有常被如期出。
p.101 Don't let the fear that testing can't catch all bugs stop you from writing the tests that will
catch most bugs.
不要因椤yo法捕捉所有臭x」，就不撰ya，因y的_可以捕捉
到大多党粝x。
索 引
Refactoring C Improving the Design of Existing Code
419
索引
  
A Account class, 296-98
Algorithm, substitute, 139-40
Amount calculation, moving, 16
amountFor, 12, 14-16
APIs, 65
Arrays
encapsulating, 215-16
replace with object, 186-88
example, 187-88
mechanics, 186-87
motivation, 186
ASCII (American Standard Code for
Information Interchange), 26, 33
Assertion, introduce, 267-70
example, 268-70
mechanics, 268
motivation, 267-68
Assignments, removing to parameters,
131-34
example, 132-33
mechanics, 132
motivation, 131
pass by value in Java, 133-34
Association
bidirectional, 200-203
unidirectional, 197-99
AWT (Abstract Windows Toolkit), 78
B Back pointer defined, 197
Behavior, moving into class, 213-14
Bequest, refused, 87
Bidirectional association, change to
unidirectional, 200-203
example, 201-3
mechanics, 200-201
motivation, 200
Body, pull up constructor, 325-27
example, 326-27
mechanics, 326
motivation, 325
Boldface code, 105
boundary conditions, 99
BSD (Berkeley Software Distribution), 388
Bug detector and suite of tests, 90
Bugs
and fear of writing tests, 101
refactor when fixing, 58-59
refactoring helps find, 57
unit tests that expose, 97
C C++ programs, refactoring, 384-87
closing comments, 387
language features complicating
refactoring, 386-87
programming styles complicating
refactoring, 386-87
Calculations
frequent renter point, 36
moving amount, 16
Calls, method, 271-318
Case statement, 47
Case statement, parent, 47
Chains, message, 84
索 引
Refactoring C Improving the Design of Existing Code
420
Change, divergent, 79
ChildrensPrice class, 47
Class; See also Classes; Subclass;
Superclass
Account, 296-98
ChildrensPrice, 47
Customer, 4-5, 18-19, 23, 26-29, 263,
347
Customer implements Nullable, 263
data, 86-87
DateRange, 297
Department, 340
diagrams, 30-31
Employee, 257, 332, 337-38
EmployeeType, 258-59
Engineer, 259
Entry, 296
extract, 149-53
example, 150-53
mechanics, 149-50
motivation, 149
FileReaderTester, 92-94
GUI, 78, 170
HtmlStatement, 348-50
incomplete library, 86
inline, 154-56
example, 155-56
mechanics, 154
motivation, 154
IntervalWindow, 191, 195
JobItem, 332-35
LaborItem, 333-34
large, 78
lazy, 83
MasterTester, 101
Movie, 2-3, 35, 37, 40-41, 43-45, 49
moving behavior into, 213-14
NewReleasePrice, 47, 49
NullCustomer, 263, 265
Party, 339
Price, 45-46, 49
RegularPrice, 47
Rental, 3, 23, 34-37, 48
replace record with data, 217
example, 220-22
mechanics, 219
motivation, 218-19
replace type code with, 218-22
Salesman, 259
Site, 262, 264
Statement, 351
TextStatement, 348-50
Classes
alternative, 85-86
do a find across all, 19
Clauses, replace nested conditional with
guard, 250-54
Clumps, data, 81
Code
before and after refactoring, 9-11
bad smells in, 75-88
alternative classes with different
interfaces, 85-86
comments, 87-88
data class, 86-87
data clumps, 81
divergent change, 79
duplicated code, 76
feature envy, 80-81
inappropriate intimacy, 85
incomplete library class, 86
large class, 78
lazy class, 83
long method, 76-77
long parameter list, 78-79
message chains, 84
middle man, 85
parallel inheritance hierarchies, 83
primitive obsession, 81-82
refused bequest, 87
shotgun surgery, 80
speculative generality, 83-84
switch statements, 82
temporary field, 84
boldface, 105
duplicated, 76
refactoring and cleaning up, 54
refactorings reduce amount of, 32
renaming, 15
replacing conditional logic on price,
34-51
self-testing, 89-91
Code review, refactor when doing, 59
索 引
Refactoring C Improving the Design of Existing Code
421
Code with exception, replace error, 310-14
Collection, encapsulate, 208-16
Comments, 87-88
Composing methods, 109-40
Conditional
decompose, 238-39
example, 239
mechanics, 238-39
motivation, 238
nested, 250-54
replace with polymorphism, 255-59
example, 257-59
mechanics, 256-57
motivation, 255-56
Conditional expressions, 237-70
consolidate, 240-42
examples, Ands, 242
examples, Ors, 241
mechanics, 241
motivation, 240
simplifying, 237-70
consolidate conditional expressions,
240-42
consolidate duplicate conditional
fragments, 243-44
decompose conditional, 238-39
introduce assertion, 267-70
introduce null object, 260-66
remove control flag, 245-49
replace conditional with
polymorphism, 255-59
replace nested conditional with guard
clauses, 250-54
Conditional fragments, consolidate
duplicate, 243-44
example, 244
mechanics, 243-44
motivation, 243
Conditions
boundary, 99
reversing, 253-54
Constant, replace magic number with
symbolic, 204-5
mechanics, 205
motivation, 204-5
Constructor body, pull up, 325-27
example, 326-27
mechanics, 326
motivation, 325
Constructor, replace with factory method,
304-7
example, 305
example, creating subclasses with
explicit methods, 307
example, creating subclasses with string,
305-7
mechanics, 304-5
motivation, 304
Control flag, remove, 245-49
examples, control flag replaced with
break, 246-47
examples, using return with control flag
result, 248-49
mechanics, 245-46
motivation, 245
Creating nothing, 68-69
Customer class, 4-5, 18-19, 23, 26-29, 263,
347
Customer implements Nullable class, 263
Customer.statement, 20
D
Data
clumps, 81
duplicate observed, 189-96
example, 191-96
mechanics, 190
motivation, 189-90
organizing, 169-235
change bidirectional association to
unidirectional, 200-203
change reference to value, 183-85
change unidirectional association to
bidirectional, 197-99
change value to reference, 179-82
duplicate observed data, 189-96
encapsulate collection, 208-16
encapsulate field, 206-7
replace array with object, 186-88
replace data value with object, 175-78
replace magic number with symbolic
constant, 204-5
索 引
Refactoring C Improving the Design of Existing Code
422
Data (continued)
organizing (continued)
replace record with data class, 217
replace subclass with fields, 232-35
replace type code with class, 218-22
replace type code with state/strategy,
227-31
replace type code with subclasses,
223-26
self encapsulate field, 171-74
using event listeners, 196
Data class, 86-87
Data class, replace record with, 217
mechanics, 217
motivation, 217
Data value, replace with object, 175-78
example, 176-78
mechanics, 175-76
motivation, 175
Databases
problems with, 63-64
programs, 403-4
DateRange class, 297
Delegate, hide, 157-59
example, 158-59
mechanics, 158
motivation, 157-58
Delegation
replace inheritance with, 352-54
example, 353-54
mechanics, 353
motivation, 352
replace with inheritance, 355-57
example, 356-57
mechanics, 356
motivation, 355
Department class, 340
Department.getTotalAnnualCost, 339
Design
changes difficult to refactor, 65-66
procedural, 368-69
and refactoring, 66-69
up front, 67
Developers reluctant to refactor own
programs, 381-93
how and where to refactor, 382-87
refactoring C++ programs, 384-87
Diagrams, Unified Modeling Language
(UML), 24-25
Divergent change, 79
Domain, separate from presentation, 370-74
example, 371-74
mechanics, 371
motivation, 370
double, 12
double getPrice, 122-23
Downcast, encapsulate, 308-9
Duplicated code, 76
E
each, 9
Employee class, 257, 332, 337-38
Employee.getAnnualCost, 339
EmployeeType class, 258-59
Encapsulate, collection, 208-16
examples, 209-10
examples, encapsulating arrays, 215-16
examples, Java 1.1, 214-15
examples, Java 2, 210-12
mechanics, 208-9
motivation, 208
moving behavior into class, 213-14
Encapsulate, downcast, 308-9
example, 309
mechanics, 309
motivation, 308
Encapsulate, field, 206-7
mechanics, 207
motivation, 206
Encapsulate field, self, 171-74
Encapsulating arrays, 215-16
EndField_FocusLost, 192, 194
Engineer class, 259
Entry class, 296
Error code, replace with exception, 310-14
example, 311-12
example, checked exceptions, 313-14
example, unchecked exceptions, 312-13
mechanics, 311
motivation, 310
Event listeners, using, 196
索 引
Refactoring C Improving the Design of Existing Code
423
Exception, replace error code with, 310-14
example, 311-12, 316-18
checked exceptions, 313-14
unchecked exceptions, 312-13
mechanics, 311, 315-16
motivation, 310, 315
Exception, replace with test, 315-18
Exceptions
checked, 313-14
and tests, 100
unchecked, 312-13
Explicit methods, creating subclasses with,
307
Explicit methods, replace parameter with,
285-87
Expressions, conditional, 237-70
Extension, introduce local, 164-68
examples, 165-68
mechanics, 165
motivation, 164-65
using subclass, 166
using wrappers, 166-68
Extract
class, 149-53
example, 150-53
mechanics, 149-50
motivation, 149
interface, 341-43
example, 342-43
mechanics, 342
motivation, 341-42
method, 13, 22, 110-16, 126-27
subclass, 330-35
example, 332-35
mechanics, 331
motivation, 330
superclass, 336-40
example, 337-40
mechanics, 337
motivation, 336
Extreme programming, 71
F
Factory method, replace constructor with,
304-7
example, 305
example, creating subclasses with
explicit methods, 307
example, creating subclasses with string,
305-7
mechanics, 304-5
motivation, 304
Feature envy, 80-81
Features, moving between objects, 141-68
Field; See also Fields
encapsulate, 206-7
mechanics, 207
motivation, 206
move, 146-48
example, 147-48
mechanics, 146-47
motivation, 146
using self-encapsulation, 148
pull up, 320-21
mechanics, 320-21
motivation, 320
push down, 329
mechanics, 329
motivation, 329
replacing price code field with price, 43
self encapsulate, 171-74
temporary, 84
Fields
replace subclass with, 232-35
example, 233-35
mechanics, 232-33
motivation, 232
FileReaderTester class, 92-94
Flag, remove control, 245-49
Foreign method, introduce, 162-63
example, 163
mechanics, 163
motivation, 162-63
Form template method, 345-51
example, 346-51
mechanics, 346
motivation, 346
Frequent renter points
calculation, 36
extracting, 22-25
frequentRenterPoints, 23, 26-27,
Function and refactoring, adding, 54
Function, refactor when adding, 58
Functional tests, 96-97
索 引
Refactoring C Improving the Design of Existing Code
424
G Gang of Four patterns, 39
Generality, speculative, 83-84
Generalization, 319-57
Generalization, dealing with, 319-57
collapse hierarchy, 344
extract interface, 341-43
extract subclass, 330-35
extract superclass, 336-40
form template method, 345-51
pull up constructor body, 325-27
pull up field, 320-21
pull up method, 322-24
push down field, 329
push down method, 328
replace delegation with inheritance,
355-57
replace inheritance with delegation,
352-54
getCharge, 34-36, 44-46
getFlowBetween, 297-99
getFrequentRenterPoints, 37, 48-49
getPriceCode, 42-43
Guard clauses, replace nested conditional
with, 250-54
example, 251-53
example, reversing conditions, 253-54
mechanics, 251
motivation, 250-51
GUI class, 78, 170
GUIs (graphical user interfaces), 189, 194,
370
H Hide delegate, 157-59
example, 158-59
mechanics, 158
motivation, 157-58
Hierarchies, parallel inheritance, 83
Hierarchy
collapse, 344
mechanics, 344
motivation, 344
extract, 375-78
example, 377-78
mechanics, 376-77
motivation, 375-76
HTML, 6-7, 9, 26
htmlStatement, 32-33
HtmlStatement class, 348-50
I Inappropriate intimacy, 85
Indirection and refactoring, 61-62
Inheritance, 38
replace delegation with, 355-57
example, 356-57
mechanics, 356
motivation, 355
replace with delegation, 352-54
example, 353-54
mechanics, 353
motivation, 352
tease apart, 362-67
examples, 364-67
mechanics, 363
motivation, 362-63
using on movie, 38
Inheritance hierarchies, parallel, 83
Inline
class, 154-56
example, 155-56
mechanics, 154
motivation, 154
method, 117-18
temp, 119
Interface, extract, 341-43
example, 342-43
mechanics, 342
motivation, 341-42
Interfaces
alternative classes with different, 85-86
changing, 64-65
published, 64
publishing, 65
IntervalWindow class, 191, 195
Intimacy, inappropriate, 85
J
Java
1.1, 214-15
2, 210-12
pass by value in, 133-34
JobItem class, 332-35
索 引
Refactoring C Improving the Design of Existing Code
425
JUnit testing framework, 91-97
unit and functional tests, 96-97
L LaborItem class, 333-34
Language features complicating refactoring,
386-87
Large class, 78
Lazy class, 83
LengthField_FocusLost, 192
Library class, incomplete, 86
List, long parameter, 78-79
Listeners, using event, 196
Local extension, introduce, 164-68
examples, 165-68
mechanics, 165
motivation, 164-65
using subclass, 166
using wrappers, 166-68
Local variables, 13
no, 112
reassigning, 114-16
using, 113-14
Localized tests, 94
Long method, 76-77
Long parameter list, 78-79
MM
agic number, replace with symbolic
constant, 204-5
mechanics, 205
motivation, 204-5
Managers, telling about refactoring to,
60-62
MasterTester class, 101
Message chains, 84
Method and objects, 17
Method calls, making simpler, 271-318
add parameter, 275-76
encapsulate downcast, 308-9
hide method, 303
introduce parameter object, 295-99
parameterize method, 283-84
preserve whole object, 288-91
remove parameter, 277-78
remove setting method, 300-302
rename method, 273-74
replace constructor with factory method,
304-7
replace error code with exception,
310-14
replace exception with test, 315-18
replace parameter with explicit methods,
285-87
replace parameter with method, 292-94
separate query from modifier, 279-82
Method object, replace method with,
135-38
example, 136-38
mechanics, 136
motivation, 135-36
Method; See also Methods
creating overriding, 47
example with Extract, 126-27
extract, 110-16
mechanics, 111
motivation, 110-11
no local variables, 112
reassigning local variables, 114-16
using local variables, 113-14
finding every reference to old, 18
form template, 345-51
example, 346-51
mechanics, 346
motivation, 346
hide, 303
mechanics, 303
motivation, 303
inline, 117-18
long, 76-77
move, 142-45
example, 144-45
mechanics, 143-44
motivation, 142
parameterize, 283-84
example, 284
mechanics, 283
motivation, 283
pull up, 322-24
example, 323-24
mechanics, 323
motivation, 322-23
索 引
Refactoring C Improving the Design of Existing Code
426
Method (continued)
push down, 328
mechanics, 328
motivation, 328
remove setting, 300-302
example, 301-2
mechanics, 300
motivation, 300
rename, 273-74
example, 274
mechanics, 273-74
motivation, 273
replace constructor with factory, 304-7
example, 305
example, creating subclasses with
explicit methods, 307
example, creating subclasses with
string, 305-7
mechanics, 304-5
motivation, 304
replace parameter with, 292-94
Methods
composing, 109-40
extract method, 110-16
inline method, 117-18
inline temp, 119
introduce explaining variables, 124-27
removing assignments to parameters,
131-34
replace method with method object,
135-38
replace temp with query, 120-23
split temporary variables, 128-30
substitute algorithm, 139-40
creating subclasses with explicit, 307
replace parameter with explicit, 285-87
Middle man, 85
Middle man, remove, 160-61
example, 161
mechanics, 160
motivation, 160
Model, 370
Modifier, separate query from, 279-82
Move, field, 146-48
Move, method, 142-45
example, 144-45
mechanics, 143-44
motivation, 142
Movie
class, 2-3, 35, 37, 40-41, 43-45, 49
subclasses of, 38
using inheritance on, 38
MVC (model-view-controller), 189, 370
N Nested conditional, replace with guard
clauses, 250-54
example, 251-53
example, reversing conditions,
253-54
mechanics, 251
motivation, 250-51
NewReleasePrice class, 47, 49
Nothing, creating, 68-69
Null object, introduce, 260-66
example, 262-66
example, testing interface, 266
mechanics, 261-62
miscellaneous special cases, 266
motivation, 260-61
NullCustomer class, 263, 265
Numbers, magic, 204-5
O
Object; See also Objects
introduce null, 260-66
introduce parameter, 295-99
preserve whole, 288-91
example, 290-91
mechanics, 289
motivation, 288-89
replace array with, 186-88
example, 187-88
mechanics, 186-87
motivation, 186
replace data value with, 175-78
replace method with method, 135-38
example, 176-78
mechanics, 175-76
motivation, 175
Objects
convert procedural design to, 368-69
example, 369
mechanics, 369
motivation, 368-69
and method, 17
索 引
Refactoring C Improving the Design of Existing Code
427
moving features between, 141-68
extract class, 149-53
hide delegate, 157-59
inline class, 154-56
introduce foreign method, 162-63
introduce local extension, 164-68
move field, 146-48
move method, 142-45
remove middle man, 160-61
Obsession, primitive, 81-82
PP
arallel inheritance hierarchies, 83
Parameter list, long, 78-79
Parameter object, introduce, 295-99
example, 296-99
mechanics, 295-96
motivation, 295
Parameterize method, 283-84
Parameters
add, 275-76
mechanics, 276
motivation, 275
remove, 277-78
mechanics, 278
motivation, 277
removing assignments to, 131-34
example, 132-33
mechanics, 132
motivation, 131
pass by value in Java, 133-34
replace with explicit methods, 285-87
example, 286-87
mechanics, 286
motivation, 285-86
replace with method, 292-94
example, 293-94
mechanics, 293
motivation, 292-93
Parent case statement, 47
Parse trees, 404
Party class, 339
Pass by value in Java, 133-34
Payroll system, optimizing, 72-73
Performance and refactoring, 69-70
Polymorphism
replace conditional with, 46, 255-59
example, 257-59
mechanics, 256-57
motivation, 255-56
replacing conditional logic on price code
with, 34-51
Presentation
defined, 370
separate domain from, 370-74
example, 371-74
mechanics, 371
motivation, 370
Price class, 45-46, 49
Price code
change movie's accessors for, 42
replacing conditional logic on, 34-51
Price code object, subclassing from, 39
Price field, replacing price code field with,
43
Price, moving method over to, 49
Price.getCharge method, 47
Primitive obsession, 81-82
Procedural design, convert to objects,
368-69
example, 369
mechanics, 369
motivation, 368-69
Programming
extreme, 71
faster, 57
styles complicating refactoring, 386-87
Programs
comments on starting, 6-7
database, 403-4
developers reluctant to refactor own,
381-93
refactoring C++, 384-87
Published interface, 64
Pull up
constructor body, 325-27
field, 320-21
mechanics, 320-21
motivation, 320
method, 322-24
example, 323-24
mechanics, 323
motivation, 322-23
索 引
Refactoring C Improving the Design of Existing Code
428
Push down
field, 329
mechanics, 329
motivation, 329
method, 328
mechanics, 328
motivation, 328
Q
Query
Replace Temp with, 21
replace temp with, 120-23
separate from modifier, 279-82
concurrency issues, 282
example, 280-82
mechanics, 280
motivation, 279
R Reality check, 380-81, 394
Record, replace with data class, 217
mechanics, 217
motivation, 217
Refactor; See also Refactoring;
Refactorings
design changes difficult to, 65-66
how and where to, 382-87
when adding function, 58
when doing code review, 59
when fixing bugs, 58-59
when not to, 66
when to, 57-60
refactor when adding function, 58
refactor when doing code review, 59
refactor when fixing bugs, 58-59
rule of three, 58
Refactoring and function, adding, 54
Refactoring Browser, 401-2
Refactoring; See also Refactor;
Refactorings, 1-52
to achieve near-term benefits, 387-89
and adding function, 54
C++ programs, 384-87
and cleaning up code, 54
code before and after, 9-11
comments on starting program, 6-7
decomposing and redistributing
statement method, 8-33
defined, 53-55
and design, 66-69
creating nothing, 68-69
does not change observable behavior of
software, 54
first example, 1-52
final thoughts, 51-52
first step in, 7-8
helps find bugs, 57
helps program faster, 57
improves design of software, 55-56
and indirection, 61-62
language features complicating, 386-87
learning, 409-12
backtrack, 410-11
duets, 411
get used to picking goals, 410
stop when unsure, 410
makes software easier to understand,
56-57
noun form, 53
origin of, 71-73
optimizing payroll system, 72-73
and performance, 69-70
principles in, 53-73
problems with, 62-66
changing interfaces, 64-65
databases, problems with, 63-64
design changes difficult to refactor,
65-66
when not to refactor, 66
programming styles complicating,
386-87
putting it all together, 409-12
reason for using, 55-57
reducing overhead of, 389-90
resources and references for, 394-95
reuse, and reality, 379-99
developers reluctant to refactor own
programs, 381-93
implications regarding software reuse,
395-96
reality check, 380-81, 394
resources and references for
refactoring, 394-95
technology transfer, 395-96
索 引
Refactoring C Improving the Design of Existing Code
429
safely, 390-93
starting point, 1-7
with tools, 401-3
verb form, 54
why it works, 60
Refactoring tools, 401-7
practical criteria for, 405-6
integrated with tools, 406
speed, 405-6
undo, 406
technical criteria for, 403-5
tools, technical criteria for
accuracy, 404-5
parse trees, 404
program database, 403-4
wrap up, 407
Refactorings; See also Refactor;
Refactoring
big, 359-78
convert procedural design to objects,
368-69
extract hierarchy, 375-78
four, 361
importance of, 360
nature of game, 359-60
separate domain from presentation,
370-74
tease apart inheritance, 362-67
catalog of, 103-7
finding references, 105-6
maturity of refactorings, 106-7
format of, 103-5
maturity of, 106-7
reduce amount of code, 32
Reference
change to value, 183-85
example, 184-85
mechanics, 184
motivation, 183
change value to, 179-82
example, 180-82
mechanics, 179-80
motivation, 179
References, finding, 105-6
RegularPrice class, 47
Removing temps, 26-33
Rename method, 273-74
Renaming code, 15
Rental class, 3, 23, 34-37, 48
Rental.getCharge, 20
Renter points, extracting frequent, 22-25
Replacing totalAmount, 27
Rule of three, 58
SS
alesman class, 259
Scoped variables, locally, 23
Self encapsulate field, 171-74
example, 172-74
mechanics, 172
motivation, 171-72
Self-encapsulation, using, 148
Self-testing code, 89-91
Setting method, remove, 300-302
example, 301-2
mechanics, 300
motivation, 300
Shotgun surgery, 80
Site class, 262, 264
Software
and refactoring, 56-57
refactoring, does not change, 54
refactoring improves design of, 55-56
reuse, 395-96
Speculative generality, 83-84
StartField_FocusLost, 192
State/strategy, replace type code with,
227-31
example, 228-31
mechanics, 227-28
motivation, 227
Statement
case, 47
class, 351
Statement method, decomposing and
redistributing, 8-33
Statements
parent case, 47
switch, 82
Subclass; See also Subclasses
extract, 330-35
example, 332-35
mechanics, 331
motivation, 330
索 引
Refactoring C Improving the Design of Existing Code
430
Subclass (continued)
replace with fields, 232-35
example, 233-35
mechanics, 232-33
motivation, 232
using, 166
Subclasses
creating with explicit methods, 307
replace type code with, 223-26
example, 224-26
mechanics, 224
motivation, 223-24
Superclass, extract, 336-40
example, 337-40
mechanics, 337
motivation, 336
Surgery, shotgun, 80
Switch statements, 82
Symbolic constant, replace magic number
with, 204-5
T Technology transfer, 395-96
Temp
inline, 119
replace with query, 120-23
example, 122-23
mechanics, 121
motivation, 120-21
Template method, form, 345-51
example, 346-51
mechanics, 346
motivation, 346
Temporary field, 84
Temporary variables, 21, 128-30
Temps, See also Temporary variables
removing, 26-33
Test
replace exception with, 315-18
example, 316-18
mechanics, 315-16
motivation, 315
suite, 98
TestEmptyRead, 99
testRead, 95
testReadAtEnd, 98
testReadBoundaries()throwsIOException,
99-100
Tests
adding more, 97-102
and boundary conditions, 99
bugs and fear of writing, 101
building, 89-102
adding more tests, 97-102
JUnit testing framework, 91-97
self-testing code, 89-91
and exceptions, 100
frequently run, 94
fully automatic, 90
localized, 94
unit and functional, 96-97
writing and running incomplete, 98
TextStatement class, 348-50
thisAmount, 9, 21
Tools, refactoring, 401-7
totalAmount, 26
replacing, 27
Trees, parse, 404
Type code
replace with class, 218-22
example, 220-22
mechanics, 219
motivation, 218-19
replace with state/strategy, 227-31
example, 228-31
mechanics, 227-28
motivation, 227
replace with subclasses, 223-26
example, 224-26
mechanics, 224
motivation, 223-24
U UML (
Unified Modeling Language), 104
diagrams, 24-25
Unidirectional association, change to
bidirectional, 197-99
example, 198-99
mechanics, 197-98
motivation, 197
索 引
Refactoring C Improving the Design of Existing Code
431
Unit and functional tests, 96-97
Up front design, 67
VV
alue, change reference to, 183-85
example, 184-85
mechanics, 184
motivation, 183
Value, change to reference, 179-82
example, 180-82
mechanics, 179-80
motivation, 179
Variables
introduce explaining, 124-27
example, 125-26
example with Extract Method, 126-27
mechanics, 125
motivation, 124
local, 13
locally scoped, 23
no local, 112
reassigning local, 114-16
split temporary, 128-30
example, 129-30
mechanics, 128-29
motivation, 128
temporary, 21
using local, 113-14
View, 370
W Wrappers, using, 166-68
Refactoring C Improving the Design of Existing Code
奈兜溃smell） 常用的重手法（Common Refactoring）
Alternative Classes with
Different Interfaces,
p85
Rename Method (273), Move Method (142)
Comments, p87 Extract Method (110), Introduce Assertion (267)
Data Class, p86 Move Method (142), Encapsulate Field (206),
Encapsulate Collection (208)
Data Clumps, p81 Extract Class (149), Introduce Parameter Object (295),
Preserve Whole Object (288)
Divergent Change, p79 Extract Class (149)
Duplicated Code, p76 Extract Method (110), Extract Class (149),
Pull Up Method (322), Form Template Method (345)
Feature Envy, p80 Move Method (142), Move Field (146), Extract Method (110)
Inappropriate Intimacy,
p85
Move Method (142), Move Field (146), Change Bidirectional
Association to Unidirectional (200), Replace Inheritance
with Delegation (352), Hide Delegate (157)
Incomplete Library
Class, p86
Introduce Foreign Method (162),
Introduce Local Extension (164)
Large Class, p78 Extract Class (149), Extract Subclass (330), Extract
Interface (341), Replace Data Value with Object (175)
Lazy Class, p.83 Inline Class (154), Collapse Hierarchy (344)
Long Method, p76 Extract Method (110), Replace Temp With Query (120),
Replace Method with Method Object (135),
Decompose Conditional (238)
※g]：各N奈兜溃smell）和各N重手法（refactorings）之中文g名目及正文
Refactoring C Improving the Design of Existing Code
奈兜溃smell） 常用的重手法（Common Refactoring）
Long Parameter List,
p78
Replace Parameter with Method (292), Introduce
Parameter Object (295), Preserve Whole Object (288)
Message Chains, p84 Hide Delegate (157)
Middle Man, p85 Remove Middle Man (160), Inline Method (117),
Replace Delegation with Inheritance (355)
Parallel Inheritance
Hierarchies, p83
Move Method (142), Move Field (146)
Primitive Obsession, p81 Replace Data Value with Object (175), Extract Class (149),
Introduce Parameter Object (295), Replace Array with
Object (186), Replace Type Code with Class (218),
Replace Type Code with Subclasses (223),
Replace Type Code with State/Strategy (227)
Refused Bequest, p87 Replace Inheritance with Delegation (352)
Shotgun Surgery, p80 Move Method (142), Move Field (146), Inline Class (154)
Speculative Generality,
p83
Collapse Hierarchy (344), Inline Class (154),
Remove Parameter (277), Rename Method (273)
Switch Statements, p82 Replace Conditional with Polymorphism (255), Replace
Type Code with Subclasses (223), Replace Type Code with
State/Strategy (227), Replace Parameter with Explicit
Methods (285), Introduce Null Object (260)
Temporary Field, p84 Extract Class (149), Introduce Null Object (260)
※g]：各N奈兜溃smell）和各N重手法（refactorings）之中文g名目及正文